<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SCANDAL - Prediction Game</title>
    <link rel="icon" type="image/png" href="favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap"
        rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script>
    <script src="web3-config.js"></script>
    <link rel="stylesheet" href="style.css">
    <style>
        html,
        body {
            height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }

        .game-wrapper {
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: var(--bg-primary);
        }

        /* Header */
        .game-header {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 2rem;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        .game-logo {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .game-logo h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            background: linear-gradient(135deg, var(--accent-cyan), var(--accent-green));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0;
        }

        .game-logo .oracle {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            color: var(--text-primary);
            margin-left: 0.3rem;
        }

        .game-logo .token {
            color: var(--accent-cyan);
            font-size: 0.9rem;
        }

        .game-nav {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .game-nav a,
        .game-nav button {
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
        }

        /* Main Content */
        .game-main {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 1.5rem;
            padding: 1.5rem 2rem;
            min-height: 0;
        }

        /* Left: Voting Panel */
        .voting-panel {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .panel-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            color: var(--accent-cyan);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .rules-link {
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            border: 1px solid var(--border-color);
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            background: transparent;
        }

        .rules-link:hover {
            border-color: var(--accent-cyan);
            color: var(--accent-cyan);
        }

        .cycle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, rgba(0, 20, 40, 0.9) 0%, rgba(0, 40, 60, 0.8) 50%, rgba(0, 20, 40, 0.9) 100%);
            border: 1px solid rgba(0, 240, 255, 0.3);
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            position: relative;
            overflow: hidden;
        }

        .cycle-row::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 240, 255, 0.03) 2px,
                    rgba(0, 240, 255, 0.03) 4px);
            pointer-events: none;
            z-index: 0;
        }

        .cycle-info {
            position: relative;
            z-index: 1;
            text-align: center;
            min-width: 180px;
        }

        .cycle-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .cycle-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            color: var(--text-primary);
        }

        .timer-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            color: var(--accent-cyan);
            min-width: 150px;
            display: inline-block;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        .timer-value.closed {
            color: var(--accent-red);
        }

        .articles-bar {
            text-align: center;
            padding: 0.8rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 1rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .vote-section {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .vote-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }

        .vote-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.8rem;
            flex: 1;
        }

        .vote-btn {
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 10px;
            background: var(--bg-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .vote-btn.mint {
            color: var(--accent-green);
            border: 2px solid rgba(0, 255, 136, 0.4);
            border-bottom: 4px solid var(--accent-green);
        }

        .vote-btn.burn {
            color: var(--accent-red);
            border: 2px solid rgba(239, 68, 68, 0.4);
            border-bottom: 4px solid var(--accent-red);
        }

        .vote-btn.neutral {
            color: var(--accent-cyan);
            border: 2px solid rgba(6, 182, 212, 0.4);
            border-bottom: 4px solid var(--accent-cyan);
        }

        .vote-btn:hover:not(:disabled) {
            transform: scale(1.03);
        }

        .vote-btn.mint:hover:not(:disabled),
        .vote-btn.mint.selected {
            box-shadow: 0 0 25px rgba(16, 185, 129, 0.5);
        }

        .vote-btn.burn:hover:not(:disabled),
        .vote-btn.burn.selected {
            box-shadow: 0 0 25px rgba(239, 68, 68, 0.5);
        }

        .vote-btn.neutral:hover:not(:disabled),
        .vote-btn.neutral.selected {
            box-shadow: 0 0 25px rgba(0, 240, 255, 0.5);
        }

        .vote-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Compact Vote Buttons */
        .vote-buttons.compact {
            flex: 0;
            gap: 0.5rem;
        }

        .vote-btn.compact {
            padding: 0.6rem 1rem;
            font-size: 0.85rem;
            gap: 0.3rem;
        }

        .coin-icon {
            font-size: 1rem;
        }

        /* Race Track Styles */
        .race-track {
            background: linear-gradient(180deg, rgba(0, 20, 40, 0.8) 0%, rgba(0, 40, 60, 0.6) 100%);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 1rem;
            margin-top: 0.8rem;
        }

        .race-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            color: var(--accent-cyan);
            text-align: center;
            margin-bottom: 0.8rem;
        }

        .race-lanes {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .race-lane {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .lane-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            width: 55px;
            text-align: right;
            color: var(--text-secondary);
        }

        .mint-lane .lane-label {
            color: var(--accent-green);
        }

        .neutral-lane .lane-label {
            color: var(--accent-cyan);
        }

        .burn-lane .lane-label {
            color: var(--accent-red);
        }

        .lane-track {
            flex: 1;
            height: 28px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 14px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .mint-lane .lane-track {
            border-color: rgba(16, 185, 129, 0.3);
        }

        .neutral-lane .lane-track {
            border-color: rgba(0, 240, 255, 0.3);
        }

        .burn-lane .lane-track {
            border-color: rgba(239, 68, 68, 0.3);
        }

        .coin-racer {
            position: absolute;
            left: 5%;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.2rem;
            transition: left 2.5s cubic-bezier(0.25, 0.1, 0.25, 1);
            filter: drop-shadow(0 0 5px currentColor);
            animation: coinBounce 0.5s ease-in-out infinite;
        }

        .mint-racer {
            color: #22c55e;
        }

        .neutral-racer {
            color: #00f0ff;
        }

        .burn-racer {
            color: #ef4444;
        }

        @keyframes coinBounce {

            0%,
            100% {
                transform: translateY(-50%) scale(1);
            }

            50% {
                transform: translateY(-50%) scale(1.1);
            }
        }

        .finish-line {
            position: absolute;
            right: 10px;
            top: 2px;
            bottom: 2px;
            width: 3px;
            background: repeating-linear-gradient(0deg,
                    #fff 0px,
                    #fff 4px,
                    #000 4px,
                    #000 8px);
            border-radius: 2px;
            opacity: 0.5;
        }

        .race-score {
            text-align: center;
            margin-top: 0.6rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .race-score span {
            color: var(--accent-cyan);
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
        }

        /* Winner Celebration Overlay */
        .race-winner-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            border-radius: 10px;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            animation: overlayFadeIn 0.5s ease-out;
        }

        .race-winner-overlay.active {
            display: flex;
        }

        @keyframes overlayFadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .confetti-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
        }

        .confetti {
            position: absolute;
            font-size: 1.2rem;
            animation: confettiFall 2s ease-in-out infinite;
        }

        .confetti.c1 {
            left: 10%;
            animation-delay: 0s;
        }

        .confetti.c2 {
            left: 25%;
            animation-delay: 0.3s;
        }

        .confetti.c3 {
            left: 40%;
            animation-delay: 0.1s;
        }

        .confetti.c4 {
            left: 60%;
            animation-delay: 0.4s;
        }

        .confetti.c5 {
            left: 75%;
            animation-delay: 0.2s;
        }

        .confetti.c6 {
            left: 90%;
            animation-delay: 0.5s;
        }

        @keyframes confettiFall {
            0% {
                transform: translateY(-20px) rotate(0deg);
                opacity: 1;
            }

            100% {
                transform: translateY(120px) rotate(360deg);
                opacity: 0;
            }
        }

        .finish-flag {
            font-size: 2.5rem;
            animation: flagWave 0.5s ease-in-out infinite alternate;
            margin-bottom: 0.5rem;
        }

        @keyframes flagWave {
            from {
                transform: rotate(-5deg) scale(1);
            }

            to {
                transform: rotate(5deg) scale(1.1);
            }
        }

        .winner-badge {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.3rem;
            padding: 0.8rem 1.5rem;
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 200, 100, 0.1));
            border: 2px solid var(--accent-green);
            animation: badgePulse 1s ease-in-out infinite;
        }

        .winner-badge.mint {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.3), rgba(0, 200, 100, 0.1));
            border-color: var(--accent-green);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
        }

        .winner-badge.neutral {
            background: linear-gradient(135deg, rgba(0, 240, 255, 0.3), rgba(0, 180, 220, 0.1));
            border-color: var(--accent-cyan);
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.5);
        }

        .winner-badge.burn {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(200, 50, 50, 0.1));
            border-color: var(--accent-red);
            box-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
        }

        @keyframes badgePulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .winner-icon {
            font-size: 2rem;
        }

        .winner-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .winner-action {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--accent-green);
        }

        .winner-badge.mint .winner-action {
            color: var(--accent-green);
        }

        .winner-badge.neutral .winner-action {
            color: var(--accent-cyan);
        }

        .winner-badge.burn .winner-action {
            color: var(--accent-red);
        }

        /* Make race-track position relative for overlay */
        .race-track {
            position: relative;
        }

        /* Winner animation */
        .coin-racer.winner {
            animation: winnerPulse 0.3s ease-in-out infinite;
        }

        @keyframes winnerPulse {

            0%,
            100% {
                transform: translateY(-50%) scale(1.2);
                filter: drop-shadow(0 0 15px currentColor);
            }

            50% {
                transform: translateY(-50%) scale(1.4);
                filter: drop-shadow(0 0 25px currentColor);
            }
        }

        .vote-message {
            text-align: center;
            padding: 0.8rem;
            border-radius: 8px;
            margin-top: 0.8rem;
            font-size: 0.9rem;
        }

        .vote-message.success {
            background: rgba(16, 185, 129, 0.15);
            border: 1px solid var(--accent-green);
            color: var(--accent-green);
        }

        .vote-message.error {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid var(--accent-red);
            color: var(--accent-red);
        }

        /* Right: Stats + Panels */
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
            min-height: 0;
            align-items: stretch;
        }

        .stats-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }

        .stat-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: var(--accent-cyan);
        }

        .stat-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-top: 0.3rem;
        }

        .leaderboard-panel {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .leaderboard-list {
            flex: 1;
            overflow-y: auto;
            min-height: 0;
        }

        .leaderboard-item {
            display: grid;
            grid-template-columns: 40px 1fr 80px 60px;
            align-items: center;
            padding: 0.8rem 0.5rem;
            background: var(--bg-secondary);
            border-radius: 6px;
            margin-bottom: 0.4rem;
            font-size: 0.9rem;
        }

        .leaderboard-rank {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-cyan);
        }

        .leaderboard-rank.gold {
            color: #ffd700;
        }

        .leaderboard-rank.silver {
            color: #c0c0c0;
        }

        .leaderboard-rank.bronze {
            color: #cd7f32;
        }

        .leaderboard-wallet {
            color: var(--text-primary);
        }

        .leaderboard-points {
            color: var(--accent-green);
            text-align: right;
        }

        .leaderboard-streak {
            color: var(--text-secondary);
            text-align: right;
        }

        /* Rules Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-card);
            border: 1px solid var(--accent-cyan);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-cyan);
            font-size: 1.2rem;
        }

        .modal-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: var(--accent-red);
            color: white;
        }

        .rules-list {
            list-style: none;
            padding: 0;
        }

        .rules-list li {
            padding: 0.8rem 0;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
        }

        .rules-list li:last-child {
            border-bottom: none;
        }

        .rule-name {
            color: var(--text-secondary);
        }

        .rule-val {
            color: var(--accent-cyan);
            font-family: 'Orbitron', sans-serif;
        }

        /* Pool Section */
        .pool-section {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .pool-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.8rem;
        }

        .pool-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .pool-total {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: var(--accent-cyan);
        }

        .pool-bar {
            display: flex;
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            background: var(--bg-primary);
        }

        .pool-bar-mint {
            background: var(--accent-green);
        }

        .pool-bar-neutral {
            background: var(--accent-cyan);
        }

        .pool-bar-burn {
            background: var(--accent-red);
        }

        .pool-amounts {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            font-size: 0.8rem;
        }

        .pool-mint {
            color: var(--accent-green);
        }

        .pool-neutral {
            color: var(--accent-cyan);
        }

        .pool-burn {
            color: var(--accent-red);
        }

        .your-bet {
            margin-top: 0.8rem;
            padding-top: 0.8rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .your-bet span {
            color: var(--accent-cyan);
            font-weight: bold;
        }

        /* Panel Button - Thin clickable row (for Last Cycle) */
        .panel-btn {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.6rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--accent-cyan);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 0.5rem;
            flex-shrink: 0;
            flex-grow: 0;
            height: auto;
        }

        .panel-btn:hover {
            background: rgba(0, 240, 255, 0.1);
        }

        .panel-btn .btn-left {
            color: var(--text-secondary);
        }

        .panel-btn .btn-right {
            font-weight: bold;
        }

        /* Last Cycle Button color variants */
        .last-cycle-btn.mint {
            border-color: var(--accent-green) !important;
        }

        .last-cycle-btn.mint .btn-right {
            color: var(--accent-green);
        }

        .last-cycle-btn.burn {
            border-color: #ef4444 !important;
        }

        .last-cycle-btn.burn .btn-right {
            color: #ef4444 !important;
        }

        .last-cycle-btn.neutral {
            border-color: var(--accent-cyan) !important;
        }

        .last-cycle-btn.neutral .btn-right {
            color: var(--accent-cyan);
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-cyan);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-green);
        }

        .last-cycle-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .last-cycle-title {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .last-cycle-result {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .last-cycle-result.mint {
            color: var(--accent-green);
        }

        .last-cycle-result.burn {
            color: var(--accent-red);
        }

        .last-cycle-result.neutral {
            color: var(--accent-cyan);
        }

        .last-cycle-info {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.3rem;
        }

        /* Preview Panel - Same size for Bet History and Leaderboard */
        .preview-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.6rem 0.8rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .preview-panel:hover {
            border-color: var(--accent-cyan);
            background: rgba(0, 240, 255, 0.05);
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.4rem;
        }

        .preview-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .preview-expand {
            color: var(--accent-cyan);
            font-size: 0.7rem;
        }

        .preview-list {
            flex: 1;
            overflow-y: auto;
        }

        .preview-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.25rem 0.4rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            margin-bottom: 0.2rem;
            font-size: 0.65rem;
        }

        .preview-item.win {
            border-left: 2px solid var(--accent-green);
        }

        .preview-item.lose {
            border-left: 2px solid var(--accent-red);
        }

        /* Expandable panels - flex: 1 to fill remaining space */
        .preview-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Leaderboard Items */
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 0.5rem;
        }

        .leaderboard-item.top-3 {
            border-color: gold;
        }

        .leaderboard-rank {
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            color: var(--accent-cyan);
            min-width: 30px;
        }

        .leaderboard-wallet {
            flex: 1;
            margin-left: 0.5rem;
            font-size: 0.85rem;
        }

        .leaderboard-balance {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-green);
        }

        .bet-history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            margin-bottom: 0.3rem;
            font-size: 0.75rem;
        }

        .bet-history-item.win {
            border-left: 3px solid var(--accent-green);
        }

        .bet-history-item.lose {
            border-left: 3px solid var(--accent-red);
        }

        .bet-history-item.pending {
            border-left: 3px solid var(--accent-cyan);
        }

        .bet-history-round {
            color: var(--text-secondary);
        }

        .bet-history-choice {
            font-family: 'Orbitron', sans-serif;
        }

        .bet-history-result {
            font-family: 'Orbitron', sans-serif;
        }

        .bet-history-result.win {
            color: var(--accent-green);
        }

        .bet-history-result.lose {
            color: var(--accent-red);
        }


        /* V2 Game Balance Panel */
        .game-balance-panel {
            background: linear-gradient(135deg, rgba(0, 240, 255, 0.1), rgba(0, 255, 136, 0.1));
            border: 2px solid var(--accent-cyan);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .game-balance-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.8rem;
        }

        .game-balance-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .game-balance-amount {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: var(--accent-cyan);
            text-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
        }

        .balance-actions {
            display: flex;
            gap: 0.5rem;
        }

        .balance-btn {
            flex: 1;
            padding: 0.6rem;
            border-radius: 8px;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
        }

        .balance-btn.deposit {
            background: linear-gradient(135deg, var(--accent-green), #00b894);
            color: white;
        }

        .balance-btn.deposit:hover {
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
            transform: translateY(-2px);
        }

        .balance-btn.withdraw {
            background: linear-gradient(135deg, var(--accent-cyan), #00b4d8);
            color: white;
        }

        .balance-btn.withdraw:hover {
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.4);
            transform: translateY(-2px);
        }

        .balance-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pending-bet-info {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 8px;
            padding: 0.5rem 0.8rem;
            margin-top: 0.8rem;
            display: none;
        }

        .pending-bet-info.active {
            display: block;
        }

        .pending-bet-text {
            font-size: 0.8rem;
            color: #ffc107;
        }

        /* Unclaimed Winnings Panel */
        .unclaimed-panel {
            background: var(--bg-card);
            border: 2px solid var(--accent-green);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .unclaimed-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.8rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .unclaimed-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            color: var(--accent-green);
        }

        .unclaimed-total {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: var(--accent-green);
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .unclaimed-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .unclaimed-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.6rem 0.8rem;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            border: 1px solid rgba(0, 255, 136, 0.2);
        }

        .unclaimed-item .round-id {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .unclaimed-item .amount {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.95rem;
            color: var(--accent-green);
        }

        .unclaimed-item .claim-btn {
            background: var(--accent-green);
            color: #000;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 0.75rem;
            transition: all 0.2s;
        }

        .unclaimed-item .claim-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px var(--accent-green);
        }

        .no-unclaimed {
            text-align: center;
            padding: 1rem;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .claim-all-btn {
            width: 100%;
            padding: 0.9rem;
            background: linear-gradient(135deg, #00ff88, #00cc66);
            border: none;
            border-radius: 8px;
            color: #000;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin-top: 0.8rem;
            transition: all 0.3s;
        }

        .claim-all-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
        }

        /* Last Cycle Modal */
        .cycle-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1500;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }

        .cycle-modal-overlay.active {
            display: flex;
        }

        .cycle-modal {
            background: var(--bg-card);
            border: 1px solid var(--accent-cyan);
            border-radius: 12px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .cycle-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .cycle-modal-body {
            padding: 1rem 1.5rem;
        }

        .article-item {
            padding: 0.8rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin-bottom: 0.5rem;
        }

        .article-title {
            font-size: 0.9rem;
            color: var(--text-primary);
            margin-bottom: 0.3rem;
        }

        .article-meta {
            font-size: 0.75rem;
            color: var(--text-secondary);
            display: flex;
            justify-content: space-between;
        }

        .article-score {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-cyan);
        }

        /* ============================================
           ORACLE ARENA - Realistic 3D Scales Design
           ============================================ */
        .oracle-arena {
            background: linear-gradient(180deg, #0a1628 0%, #0d2847 50%, #0a1628 100%);
            border: 2px solid rgba(0, 240, 255, 0.4);
            border-radius: 16px;
            padding: 1.2rem;
            margin-top: 1rem;
            position: relative;
            overflow: visible;
            box-shadow:
                0 0 30px rgba(0, 240, 255, 0.15),
                inset 0 0 60px rgba(0, 20, 40, 0.8);
        }

        .arena-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.3rem;
        }

        .arena-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            color: #fff;
            letter-spacing: 3px;
        }

        .arena-status {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.75rem;
            color: var(--accent-cyan);
            background: rgba(0, 240, 255, 0.1);
            padding: 0.3rem 0.8rem;
            border-radius: 20px;
            border: 1px solid rgba(0, 240, 255, 0.3);
        }

        .arena-subtitle {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            margin-bottom: 1rem;
            letter-spacing: 1px;
        }

        /* Scales Wrapper */
        .scales-wrapper {
            position: relative;
            height: 180px;
            margin: 0 auto;
            perspective: 800px;
        }

        /* Central Balance Beam */
        .scale-beam {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: 8px;
            background: linear-gradient(90deg,
                    rgba(0, 255, 136, 0.8) 0%,
                    rgba(255, 255, 255, 0.9) 50%,
                    rgba(239, 68, 68, 0.8) 100%);
            border-radius: 4px;
            box-shadow:
                0 2px 10px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(0, 240, 255, 0.3);
            transform-origin: center center;
            transition: transform 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .scale-beam.tilt-mint {
            transform: translateX(-50%) rotate(-8deg);
        }

        .scale-beam.tilt-burn {
            transform: translateX(-50%) rotate(8deg);
        }

        .scale-beam.tilt-heavy-mint {
            transform: translateX(-50%) rotate(-15deg);
        }

        .scale-beam.tilt-heavy-burn {
            transform: translateX(-50%) rotate(15deg);
        }

        /* Scale Arms */
        .scale-arm {
            position: relative;
            width: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .left-arm {
            margin-left: 10px;
        }

        .right-arm {
            margin-right: 10px;
        }

        /* Ropes */
        .scale-rope {
            width: 3px;
            height: 45px;
            background: linear-gradient(180deg,
                    rgba(139, 90, 43, 0.9) 0%,
                    rgba(101, 67, 33, 1) 50%,
                    rgba(139, 90, 43, 0.9) 100%);
            border-radius: 1px;
            box-shadow: 1px 0 3px rgba(0, 0, 0, 0.5);
        }

        /* Scale Bowls */
        .scale-bowl {
            width: 85px;
            height: 50px;
            border-radius: 0 0 50% 50% / 0 0 100% 100%;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding-top: 5px;
            transition: transform 0.5s ease;
        }

        .mint-bowl {
            background: linear-gradient(180deg,
                    rgba(0, 255, 136, 0.2) 0%,
                    rgba(0, 200, 100, 0.4) 50%,
                    rgba(0, 150, 80, 0.6) 100%);
            border: 2px solid rgba(0, 255, 136, 0.6);
            box-shadow:
                0 5px 25px rgba(0, 255, 136, 0.4),
                inset 0 -10px 20px rgba(0, 255, 136, 0.2);
        }

        .burn-bowl {
            background: linear-gradient(180deg,
                    rgba(239, 68, 68, 0.2) 0%,
                    rgba(200, 50, 50, 0.4) 50%,
                    rgba(150, 30, 30, 0.6) 100%);
            border: 2px solid rgba(239, 68, 68, 0.6);
            box-shadow:
                0 5px 25px rgba(239, 68, 68, 0.4),
                inset 0 -10px 20px rgba(239, 68, 68, 0.2);
        }

        .bowl-glow {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 15px;
            border-radius: 50%;
            filter: blur(8px);
        }

        .mint-bowl .bowl-glow {
            background: rgba(0, 255, 136, 0.6);
            animation: mintGlow 2s ease-in-out infinite;
        }

        .burn-bowl .bowl-glow {
            background: rgba(239, 68, 68, 0.6);
            animation: burnGlow 2s ease-in-out infinite;
        }

        @keyframes mintGlow {

            0%,
            100% {
                opacity: 0.5;
                transform: translateX(-50%) scale(1);
            }

            50% {
                opacity: 1;
                transform: translateX(-50%) scale(1.2);
            }
        }

        @keyframes burnGlow {

            0%,
            100% {
                opacity: 0.5;
                transform: translateX(-50%) scale(1);
            }

            50% {
                opacity: 1;
                transform: translateX(-50%) scale(1.2);
            }
        }

        .bowl-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 2px;
        }

        .mint-bowl .bowl-label {
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }

        .burn-bowl .bowl-label {
            color: #ff4444;
            text-shadow: 0 0 10px rgba(239, 68, 68, 0.8);
        }

        .bowl-percent {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            font-weight: 900;
        }

        .mint-bowl .bowl-percent {
            color: #00ff88;
            text-shadow: 0 0 15px rgba(0, 255, 136, 1);
        }

        .burn-bowl .bowl-percent {
            color: #ff4444;
            text-shadow: 0 0 15px rgba(239, 68, 68, 1);
        }

        /* Center Pivot */
        .scale-pivot {
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }

        .pivot-top {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(255, 200, 0, 0.6);
        }

        .pivot-base {
            width: 6px;
            height: 40px;
            background: linear-gradient(180deg, #888, #444);
            margin-top: -3px;
        }

        /* NEUTRAL Badge */
        .neutral-badge {
            background: linear-gradient(135deg, rgba(0, 240, 255, 0.15), rgba(0, 180, 220, 0.25));
            border: 2px solid rgba(0, 240, 255, 0.5);
            border-radius: 25px;
            padding: 0.5rem 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: fit-content;
            margin: -20px auto 0.8rem;
            position: relative;
            z-index: 5;
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.3);
        }

        .neutral-badge .neutral-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            color: #00f0ff;
            letter-spacing: 2px;
        }

        .neutral-badge .neutral-percent {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 900;
            color: #00f0ff;
            text-shadow: 0 0 10px rgba(0, 240, 255, 0.8);
        }

        /* Arena Pool Display */
        .arena-pool {
            text-align: center;
            margin-bottom: 0.8rem;
            font-size: 0.85rem;
        }

        .arena-pool .pool-label {
            color: rgba(255, 255, 255, 0.6);
            margin-right: 0.5rem;
        }

        .arena-pool .pool-amount {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            color: var(--accent-cyan);
            text-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
        }

        /* Arena Bet Buttons */
        .arena-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.5rem;
        }

        .arena-btn {
            padding: 0.7rem 0.5rem;
            border: none;
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .arena-btn.mint-btn {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 200, 100, 0.3));
            border: 2px solid rgba(0, 255, 136, 0.5);
            color: #00ff88;
        }

        .arena-btn.mint-btn:hover {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.4), rgba(0, 200, 100, 0.5));
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            transform: translateY(-2px);
        }

        .arena-btn.burn-btn {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(200, 50, 50, 0.3));
            border: 2px solid rgba(239, 68, 68, 0.5);
            color: #ff4444;
        }

        .arena-btn.burn-btn:hover {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.4), rgba(200, 50, 50, 0.5));
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
            transform: translateY(-2px);
        }

        .arena-btn.neutral-btn {
            background: linear-gradient(135deg, rgba(0, 240, 255, 0.2), rgba(0, 180, 220, 0.3));
            border: 2px solid rgba(0, 240, 255, 0.5);
            color: #00f0ff;
        }

        .arena-btn.neutral-btn:hover {
            background: linear-gradient(135deg, rgba(0, 240, 255, 0.4), rgba(0, 180, 220, 0.5));
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.5);
            transform: translateY(-2px);
        }

        /* ======== FUTURISTIC HOLOGRAM SLIDER ======== */
        .hologram-container {
            width: 100%;
            margin: 0.5rem 0 1rem;
        }

        .hologram-panel {
            background: linear-gradient(180deg, transparent 0%, rgba(0, 240, 255, 0.05) 50%, transparent 100%);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 10px;
            padding: 0.8rem;
            position: relative;
            overflow: hidden;
        }

        .hologram-scanlines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 240, 255, 0.03) 2px,
                    rgba(0, 240, 255, 0.03) 4px);
            pointer-events: none;
            z-index: 1;
        }

        .hologram-score {
            text-align: center;
            margin-bottom: 0.5rem;
            position: relative;
            z-index: 2;
        }

        .score-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
            font-weight: 900;
            color: #00f0ff;
            text-shadow: 0 0 20px rgba(0, 240, 255, 0.8), 0 0 40px rgba(0, 240, 255, 0.4);
            line-height: 1;
        }

        .score-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            color: rgba(0, 240, 255, 0.6);
            letter-spacing: 3px;
            margin-top: 0.3rem;
        }

        .hologram-scale {
            position: relative;
            height: 12px;
            margin: 1rem 0;
            z-index: 2;
        }

        .scale-track {
            position: absolute;
            width: 100%;
            height: 6px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(90deg, #00ff88, #00f0ff 50%, #ff4444);
            border-radius: 3px;
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.4);
        }

        .scale-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-top: 18px solid #00f0ff;
            filter: drop-shadow(0 0 10px #00f0ff);
            transition: left 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 3;
        }

        .indicator-glow {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(0, 240, 255, 0.8), transparent 70%);
            border-radius: 50%;
            animation: pulseGlow 1.5s ease-in-out infinite;
        }

        @keyframes pulseGlow {

            0%,
            100% {
                transform: translateX(-50%) scale(1);
                opacity: 0.8;
            }

            50% {
                transform: translateX(-50%) scale(1.3);
                opacity: 1;
            }
        }

        .hologram-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 1rem;
            position: relative;
            z-index: 2;
        }

        .holo-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.2rem;
        }

        .label-icon {
            font-size: 1rem;
        }

        .label-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            letter-spacing: 1px;
        }

        .label-pct {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 900;
        }

        .holo-label.mint .label-name,
        .holo-label.mint .label-pct {
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        .holo-label.neutral .label-name,
        .holo-label.neutral .label-pct {
            color: #00f0ff;
            text-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
        }

        .holo-label.burn .label-name,
        .holo-label.burn .label-pct {
            color: #ff4444;
            text-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
        }

        /* ======== POOL SECTION - Holographic Style ======== */
        .pool-section {
            margin-top: 1rem;
            background: linear-gradient(180deg, rgba(0, 20, 40, 0.9) 0%, rgba(0, 40, 60, 0.8) 50%, rgba(0, 20, 40, 0.9) 100%);
            border: 1px solid rgba(0, 240, 255, 0.3);
            border-radius: 10px;
            padding: 0.8rem;
            position: relative;
            overflow: hidden;
        }

        .pool-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(0deg,
                    transparent,
                    transparent 2px,
                    rgba(0, 240, 255, 0.03) 2px,
                    rgba(0, 240, 255, 0.03) 4px);
            pointer-events: none;
            z-index: 0;
        }

        .pool-section .pool-header {
            position: relative;
            z-index: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.6rem;
        }

        .pool-section .pool-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            color: rgba(0, 240, 255, 0.6);
            letter-spacing: 3px;
        }

        .pool-section .pool-total {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: 900;
            color: #00f0ff;
            text-shadow: 0 0 15px rgba(0, 240, 255, 0.8);
        }

        .pool-section .pool-distribution {
            position: relative;
            z-index: 1;
        }

        .pool-section .pool-bar {
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            background: linear-gradient(90deg, #00ff88, #00f0ff 50%, #ff4444);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.3);
        }

        .pool-section .pool-bar-mint,
        .pool-section .pool-bar-neutral,
        .pool-section .pool-bar-burn {
            display: none;
            /* Hide individual bars, use gradient instead */
        }

        .pool-section .pool-amounts {
            display: flex;
            justify-content: space-between;
            margin-top: 0.4rem;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.75rem;
            font-weight: 700;
        }

        .pool-section .pool-mint {
            color: #00ff88;
            text-shadow: 0 0 8px rgba(0, 255, 136, 0.5);
        }

        .pool-section .pool-neutral {
            color: #00f0ff;
            text-shadow: 0 0 8px rgba(0, 240, 255, 0.5);
        }

        .pool-section .pool-burn {
            color: #ff4444;
            text-shadow: 0 0 8px rgba(255, 68, 68, 0.5);
        }
    </style>
</head>

<body>
    <div class="game-wrapper">
        <!-- Header -->
        <div class="game-header">
            <div class="game-logo">
                <h1>SCANDAL</h1>
                <span class="oracle">ORACLE</span>
            </div>
            <div class="game-nav">
                <a href="index.html#oracle" class="btn-news">DASHBOARD</a>
                <a href="news.html" class="btn-news">NEWS</a>
                <a href="game.html" class="btn-news">ORACLE</a>
                <button class="btn-connect" id="connectWallet" onclick="toggleWallet()">Connect Wallet</button>
            </div>
        </div>

        <!-- Main -->
        <div class="game-main">
            <!-- Left: Voting -->
            <div class="voting-panel">
                <div class="panel-header">
                    <h2 class="panel-title">Current Cycle</h2>
                    <button class="rules-link" onclick="openRules()">? Rules</button>
                </div>

                <div class="cycle-row">
                    <div class="cycle-info">
                        <div class="cycle-label">Cycle</div>
                        <div class="cycle-value" id="currentCycle">#--</div>
                    </div>
                    <div class="cycle-info" style="text-align: left;">
                        <div class="cycle-label" style="margin-bottom: 0.3rem;">Status</div>
                        <div class="timer-value" id="votingTimer">--:--</div>
                    </div>
                </div>

                <div class="articles-bar">
                    <span id="articlesCount">0</span> articles in cycle
                </div>



                <!-- Futuristic Holographic Balance Slider -->
                <div class="oracle-arena" id="oracleArena">

                    <!-- Futuristic Hologram Slider -->
                    <div class="hologram-container">
                        <div class="hologram-panel">
                            <!-- Scanlines effect -->
                            <div class="hologram-scanlines"></div>

                            <!-- Balance Score Display -->
                            <div class="hologram-score">
                                <div class="score-value" id="holoScore">50</div>
                                <div class="score-label">BALANCE SCORE</div>
                            </div>

                            <!-- Gradient Scale Bar -->
                            <div class="hologram-scale">
                                <div class="scale-track"></div>
                                <div class="scale-indicator" id="holoIndicator">
                                    <div class="indicator-glow"></div>
                                </div>
                            </div>

                            <!-- Labels Row -->
                            <div class="hologram-labels">
                                <div class="holo-label mint">
                                    <span class="label-icon"></span>
                                    <span class="label-name">MINT</span>
                                    <span class="label-pct" id="holoMintPct">33%</span>
                                </div>
                                <div class="holo-label neutral">
                                    <span class="label-icon"></span>
                                    <span class="label-name">NEUTRAL</span>
                                    <span class="label-pct" id="holoNeutralPct">34%</span>
                                </div>
                                <div class="holo-label burn">
                                    <span class="label-icon"></span>
                                    <span class="label-name">BURN</span>
                                    <span class="label-pct" id="holoBurnPct">33%</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Bet Buttons -->
                    <div class="arena-buttons">
                        <button class="arena-btn mint-btn" id="arenaMint" onclick="vote('MINT')"> Bet MINT</button>
                        <button class="arena-btn neutral-btn" id="arenaNeutral" onclick="vote('NEUTRAL')"> Bet
                            NEUTRAL</button>
                        <button class="arena-btn burn-btn" id="arenaBurn" onclick="vote('BURN')"> Bet BURN</button>
                    </div>

                    <!-- Pending Refunds Alert -->
                    <div class="refund-alert" id="refundAlert" style="display: none;">
                        <div class="refund-icon"></div>
                        <div class="refund-text">
                            You have <span id="refundCount">0</span> pending refund(s)
                        </div>
                        <button class="refund-btn" onclick="claimRefunds()"> Claim Refund</button>
                    </div>

                    <!-- Winner Celebration Overlay -->
                    <div class="race-winner-overlay" id="raceWinnerOverlay">
                        <div class="confetti-container">
                            <div class="confetti c1"></div>
                            <div class="confetti c2"></div>
                            <div class="confetti c3"></div>
                            <div class="confetti c4"></div>
                            <div class="confetti c5"></div>
                            <div class="confetti c6"></div>
                        </div>
                        <div class="finish-flag"></div>
                        <div class="winner-badge" id="winnerBadge">
                            <span class="winner-icon" id="winnerIcon"></span>
                            <span class="winner-text">WINNER!</span>
                            <span class="winner-action" id="winnerAction">MINT</span>
                        </div>
                    </div>
                </div>

                <!-- Pool Stats (inside voting-panel) -->
                <div class="pool-section">
                    <div class="pool-header">
                        <span class="pool-label">POOL</span>
                        <span class="pool-total" id="poolTotal">0 $SCNDL</span>
                    </div>
                    <div class="pool-distribution">
                        <div class="pool-bar">
                            <div class="pool-bar-mint" id="poolBarMint" style="width: 33%;"></div>
                            <div class="pool-bar-neutral" id="poolBarNeutral" style="width: 34%;"></div>
                            <div class="pool-bar-burn" id="poolBarBurn" style="width: 33%;"></div>
                        </div>
                        <div class="pool-amounts">
                            <span class="pool-mint" id="poolMint">0</span>
                            <span class="pool-neutral" id="poolNeutral">0</span>
                            <span class="pool-burn" id="poolBurn">0</span>
                        </div>
                    </div>
                    <div class="your-bet" id="yourBet" style="display: none;">
                        Your bet: <span id="yourBetAmount">0</span> $SCNDL on <span id="yourBetChoice">-</span>
                    </div>
                </div>

                <div class="vote-message" id="voteMessage" style="display: none;"></div>
            </div>

            <!-- Right -->
            <div class="right-panel">
                <!-- Stats Row -->
                <div class="stats-row">
                    <div class="stat-card">
                        <div class="stat-value" id="userBalance" style="color: var(--accent-cyan);">0</div>
                        <div class="stat-label">WALLET BALANCE</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="userWon" style="color: var(--accent-green);">0</div>
                        <div class="stat-label">Total Won</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="userLost" style="color: var(--accent-red);">0</div>
                        <div class="stat-label">Total Lost</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="winRate">0%</div>
                        <div class="stat-label">Win Rate</div>
                    </div>
                </div>

                <!-- V2 Game Balance Panel -->
                <div class="game-balance-panel" id="gameBalancePanel" style="display: none;">
                    <div class="game-balance-header">
                        <span class="game-balance-title">GAME BALANCE</span>
                        <span class="game-balance-amount" id="gameBalance">0 SCNDL</span>
                    </div>
                    <div class="balance-actions">
                        <button class="balance-btn deposit" onclick="openDepositModal()">DEPOSIT</button>
                        <button class="balance-btn withdraw" onclick="openWithdrawModal()">WITHDRAW</button>
                    </div>
                    <div class="pending-bet-info" id="pendingBetInfo">
                        <span class="pending-bet-text"> Pending bet: <span id="pendingBetAmount">0</span> SCNDL on
                            <span id="pendingBetChoice">-</span></span>
                    </div>
                </div>


                <!-- Last Cycle Button (thin, click for modal) -->
                <button class="panel-btn last-cycle-btn neutral" id="lastCyclePanel" onclick="openLastCycle()">
                    <span class="btn-left">LAST #<span id="lastCycleNumber">--</span></span>
                    <span class="btn-right" id="lastCycleResult">--</span>
                </button>

                <!-- Bet History Preview Panel -->
                <div class="preview-panel" id="betHistoryPanel" onclick="openBetHistoryModal()" style="display: none;">
                    <div class="preview-header">
                        <span class="preview-title">YOUR BET HISTORY</span>
                        <span class="preview-expand"></span>
                    </div>
                    <div class="preview-list" id="betHistoryPreview">
                        <p class="text-secondary" style="text-align: center; font-size: 0.7rem;">No bets yet</p>
                    </div>
                </div>

                <!-- Leaderboard Preview Panel (expands when wallet not connected) -->
                <div class="preview-panel leaderboard-expand" id="leaderboardPanel" onclick="openLeaderboardModal()">
                    <div class="preview-header">
                        <span class="preview-title">LEADERBOARD</span>
                        <span class="preview-expand"></span>
                    </div>
                    <div class="preview-list" id="leaderboardPreview" style="max-height: none; overflow-y: auto;">
                        <p class="text-secondary" style="text-align: center; font-size: 0.7rem;">Loading...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Rules Modal -->
    <div class="modal-overlay" id="rulesModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Game Rules</h3>
                <button class="modal-close" onclick="closeRules()">&times;</button>
            </div>
            <ul class="rules-list">
                <li><span class="rule-name">Bet Amount</span><span class="rule-val">1,000 $SCNDL</span></li>
                <li><span class="rule-name">Voting Window</span><span class="rule-val">First 60 seconds</span></li>
                <li><span class="rule-name">House Fee</span><span class="rule-val">5%</span></li>
                <li><span class="rule-name">Win Payout</span><span class="rule-val">Pool  Winners</span></li>
                <li><span class="rule-name">No News</span><span class="rule-val">Full Refund</span></li>
                <li><span class="rule-name">Wallet Required</span><span class="rule-val">MetaMask</span></li>
            </ul>
        </div>
    </div>

    <!-- Last Cycle Modal -->
    <div class="cycle-modal-overlay" id="lastCycleModal">
        <div class="cycle-modal">
            <div class="cycle-modal-header">
                <h3 class="modal-title">Cycle #<span id="modalCycleId">--</span> Details</h3>
                <button class="modal-close" onclick="closeLastCycle()">&times;</button>
            </div>
            <div class="cycle-modal-body">
                <div
                    style="display: flex; justify-content: space-between; margin-bottom: 1rem; padding: 0.8rem; background: var(--bg-secondary); border-radius: 8px;">
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Result</div>
                        <div id="modalCycleAction" style="font-family: 'Orbitron'; font-size: 1.2rem;">--</div>
                    </div>
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Average Score</div>
                        <div id="modalCycleScore"
                            style="font-family: 'Orbitron'; font-size: 1.2rem; color: var(--accent-cyan);">--</div>
                    </div>
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Rate</div>
                        <div id="modalCycleRate" style="font-family: 'Orbitron'; font-size: 1.2rem;">--</div>
                    </div>
                </div>
                <div style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 0.5rem;">News Articles:
                </div>
                <div id="modalArticlesList" style="max-height: 200px; overflow-y: auto;">
                    <p class="text-secondary" style="text-align: center; font-size: 0.8rem;">No articles</p>
                </div>
            </div>
        </div>
    </div> <!-- End lastCycleModal -->

    <!-- Leaderboard Modal -->
    <div class="modal-overlay" id="leaderboardModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h3 class="modal-title"> LEADERBOARD</h3>
                <button class="modal-close" onclick="closeLeaderboardModal()">&times;</button>
            </div>
            <div class="modal-body" style="padding: 1rem;">
                <input type="text" id="leaderboardSearch" placeholder="Search by wallet (last 4 chars) or ENS..."
                    style="width: 100%; padding: 0.8rem; margin-bottom: 1rem; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-family: 'Orbitron';"
                    oninput="filterLeaderboard(this.value)">
                <div id="leaderboardList" style="max-height: 400px; overflow-y: auto;">
                    <p class="text-secondary" style="text-align: center;">Loading...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Bet History Modal -->
    <div class="modal-overlay" id="betHistoryModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h3 class="modal-title"> YOUR BET HISTORY</h3>
                <button class="modal-close" onclick="closeBetHistoryModal()">&times;</button>
            </div>
            <div class="modal-body" style="padding: 1rem;">
                <div id="betHistoryList" style="max-height: 400px; overflow-y: auto;">
                    <p class="text-secondary" style="text-align: center;">Loading...</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Deposit/Withdraw Modal (MUST be outside lastCycleModal!) -->
    <div class="modal-overlay" id="depositModal">
        <div class="modal-content deposit-modal">
            <div class="modal-header">
                <h3 class="modal-title" id="depositModalTitle">DEPOSIT SCNDL</h3>
                <button class="modal-close" onclick="closeDepositModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="deposit-info">
                    <div class="deposit-balance">
                        <span class="label">Wallet Balance:</span>
                        <span class="value" id="modalWalletBalance">0 SCNDL</span>
                    </div>
                    <div class="deposit-balance">
                        <span class="label">Game Balance:</span>
                        <span class="value" id="modalGameBalance">0 SCNDL</span>
                    </div>
                </div>
                <div class="deposit-input-group">
                    <label>Amount (SCNDL)</label>
                    <input type="number" id="depositAmountInput" placeholder="Enter amount..." min="1000" step="1000">
                    <div class="quick-amounts">
                        <button onclick="setDepositAmount(1000)">1K</button>
                        <button onclick="setDepositAmount(5000)">5K</button>
                        <button onclick="setDepositAmount(10000)">10K</button>
                        <button onclick="setDepositAmount(50000)">50K</button>
                        <button onclick="setMaxDeposit()">MAX</button>
                    </div>
                </div>
                <div class="deposit-note" id="depositNote">
                    Minimum: 1,000 SCNDL
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-cancel" onclick="closeDepositModal()">Cancel</button>
                <button class="btn-confirm" id="depositConfirmBtn" onclick="confirmDeposit()">DEPOSIT</button>
            </div>
        </div>
    </div>

    <!-- Result Popup (Win/Lose) -->
    <div class="result-popup" id="resultPopup">
        <div class="result-popup-content">
            <div class="result-icon" id="resultIcon"></div>
            <h3 class="result-title" id="resultTitle">YOU WON!</h3>
            <p class="result-amount" id="resultAmount">+1,000 SCNDL</p>
            <button class="result-close-btn" onclick="closeResultPopup()">CLOSE</button>
        </div>
    </div>

    <style>
        /* Result Popup Styles */
        .result-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }

        .result-popup.active {
            display: flex;
            animation: popupFadeIn 0.3s ease;
        }

        @keyframes popupFadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .result-popup-content {
            text-align: center;
            padding: 2rem 3rem;
            background: var(--bg-card);
            border-radius: 20px;
            animation: popupBounce 0.5s ease;
        }

        @keyframes popupBounce {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .result-popup.win .result-popup-content {
            border: 3px solid var(--accent-green);
            box-shadow: 0 0 50px rgba(16, 185, 129, 0.5);
        }

        .result-popup.lose .result-popup-content {
            border: 3px solid var(--accent-red);
            box-shadow: 0 0 50px rgba(239, 68, 68, 0.5);
        }

        .result-icon {
            font-size: 4rem;
            margin-bottom: 0.5rem;
        }

        .result-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            margin-bottom: 1rem;
        }

        .result-popup.win .result-title {
            color: var(--accent-green);
        }

        .result-popup.lose .result-title {
            color: var(--accent-red);
        }

        .result-amount {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .result-popup.win .result-amount {
            color: var(--accent-green);
        }

        .result-popup.lose .result-amount {
            color: var(--accent-red);
        }

        .result-close-btn {
            padding: 0.8rem 2rem;
            background: transparent;
            border: 2px solid var(--accent-cyan);
            color: var(--accent-cyan);
            font-family: 'Orbitron', sans-serif;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .result-close-btn:hover {
            background: var(--accent-cyan);
            color: var(--bg-primary);
        }
    </style>

    <style>
        /* Modal Overlay - MUST be hidden by default! */
        #depositModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        #depositModal.active {
            display: flex;
        }

        /* Deposit Modal Styles */
        .deposit-modal {
            background: var(--bg-card);
            border: 2px solid var(--accent-cyan);
            border-radius: 16px;
            max-width: 420px;
            width: 90%;
            animation: modalSlideIn 0.3s ease;
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .deposit-modal .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.2rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .deposit-modal .modal-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            color: var(--accent-cyan);
            margin: 0;
        }

        .deposit-modal .modal-body {
            padding: 1.5rem;
        }

        .deposit-info {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 1rem;
            margin-bottom: 1.2rem;
        }

        .deposit-balance {
            display: flex;
            justify-content: space-between;
            padding: 0.4rem 0;
        }

        .deposit-balance .label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .deposit-balance .value {
            font-family: 'Orbitron', sans-serif;
            color: var(--accent-cyan);
        }

        .deposit-input-group {
            margin-bottom: 1rem;
        }

        .deposit-input-group label {
            display: block;
            color: var(--text-secondary);
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
        }

        .deposit-input-group input {
            width: 100%;
            padding: 0.9rem 1rem;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-primary);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            outline: none;
            transition: border-color 0.3s;
        }

        .deposit-input-group input:focus {
            border-color: var(--accent-cyan);
        }

        .quick-amounts {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.8rem;
        }

        .quick-amounts button {
            flex: 1;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quick-amounts button:hover {
            background: var(--accent-cyan);
            color: var(--bg-primary);
            border-color: var(--accent-cyan);
        }

        .deposit-note {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-align: center;
        }

        .deposit-modal .modal-footer {
            display: flex;
            gap: 1rem;
            padding: 1rem 1.5rem 1.5rem;
        }

        .btn-cancel {
            flex: 1;
            padding: 0.8rem;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-cancel:hover {
            border-color: var(--accent-red);
            color: var(--accent-red);
        }

        .btn-confirm {
            flex: 2;
            padding: 0.8rem;
            background: linear-gradient(135deg, var(--accent-green), #00b894);
            border: none;
            border-radius: 8px;
            color: white;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-confirm:hover {
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
            transform: translateY(-2px);
        }

        .btn-confirm.withdraw {
            background: linear-gradient(135deg, var(--accent-cyan), #00b4d8);
        }

        .btn-confirm.withdraw:hover {
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.4);
        }
    </style>

    <!-- Result Popup -->
    <div class="result-popup" id="resultPopup">
        <div class="result-content" id="resultContent">
            <div class="result-icon" id="resultIcon"></div>
            <div class="result-text" id="resultText">WIN</div>
            <div class="result-points" id="resultPoints">+10 pts</div>
            <div class="result-streak" id="resultStreak"></div>
        </div>
    </div>

    <style>
        .result-popup {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .result-popup.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        .result-content {
            text-align: center;
            animation: popIn 0.4s ease;
        }

        .result-content.win {
            color: var(--accent-green);
        }

        .result-content.lose {
            color: var(--accent-red);
        }

        .result-content.refund {
            color: var(--accent-cyan);
        }

        .result-icon {
            font-size: 5rem;
            margin-bottom: 1rem;
        }

        .result-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 4rem;
            font-weight: 900;
            margin-bottom: 0.5rem;
        }

        .result-points {
            font-family: 'Orbitron', sans-serif;
            font-size: 2rem;
        }

        .result-streak {
            font-size: 1.2rem;
            margin-top: 1rem;
            color: var(--text-secondary);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes popIn {
            from {
                transform: scale(0.5);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }
    </style>

    <script>
        let walletAddress = null;
        let currentCycleId = null;
        let myVote = null;
        let lastCycleId = null;

        // Pool simulation
        const BET_AMOUNT = 1000; // $SCNDL per bet (V2 minimum)
        let poolData = { mint: 0, neutral: 0, burn: 0 };
        let myBetAmount = 0;
        let lastCycleData = null;

        // Coin Race variables
        let currentRaceScore = 50;
        let currentCycleProgress = 0;

        // Update coin race positions based on time progress and score
        // progress: 0 to 1 (cycle progress)
        // score: 0-100 (Oracle score - lower = MINT, higher = BURN)
        // articlesCount: number of news articles (0 = no news yet)
        function updateCoinRace(progress, score, articlesCount = 0) {
            currentRaceScore = score;
            currentCycleProgress = progress;

            const raceScoreEl = document.getElementById('raceScore');
            if (raceScoreEl) raceScoreEl.textContent = Math.round(score);

            const mintRacer = document.getElementById('mintRacer');
            const neutralRacer = document.getElementById('neutralRacer');
            const burnRacer = document.getElementById('burnRacer');

            if (!mintRacer || !neutralRacer || !burnRacer) return;

            // Remove winner class during race
            if (progress < 0.95) {
                mintRacer.classList.remove('winner');
                neutralRacer.classList.remove('winner');
                burnRacer.classList.remove('winner');
            }

            // Base position: all coins move together based on time (5% to 85%)
            const startPos = 5;
            const endPos = 85;
            const basePos = startPos + progress * (endPos - startPos);

            // Score determines lead/lag offset (max 12% difference)
            // If no news yet (articlesCount === 0), all coins move together
            const maxOffset = 12;
            let mintOffset = 0, neutralOffset = 0, burnOffset = 0;

            if (articlesCount > 0) {
                // News has arrived - apply score-based offsets
                // Rules: score < 40 = MINT, 40-60 = NEUTRAL, > 60 = BURN
                if (score < 40) {
                    // MINT zone - MINT leads
                    const intensity = (40 - score) / 40; // 0 at 40, 1 at 0
                    mintOffset = intensity * maxOffset;
                    neutralOffset = -intensity * maxOffset * 0.4;
                    burnOffset = -intensity * maxOffset * 0.8;
                } else if (score > 60) {
                    // BURN zone - BURN leads
                    const intensity = (score - 60) / 40; // 0 at 60, 1 at 100
                    burnOffset = intensity * maxOffset;
                    neutralOffset = -intensity * maxOffset * 0.4;
                    mintOffset = -intensity * maxOffset * 0.8;
                } else {
                    // NEUTRAL zone (40-60) - NEUTRAL leads
                    const distFromCenter = Math.abs(50 - score);
                    const intensity = 1 - (distFromCenter / 10); // strongest at 50
                    neutralOffset = intensity * maxOffset * 0.6;
                    // Slight lean based on which side of 50
                    if (score < 50) {
                        mintOffset = -intensity * maxOffset * 0.2;
                        burnOffset = -intensity * maxOffset * 0.4;
                    } else {
                        burnOffset = -intensity * maxOffset * 0.2;
                        mintOffset = -intensity * maxOffset * 0.4;
                    }
                }
            }
            // When score === 50, all offsets remain 0 (coins move together)

            // Calculate final positions (clamped between 5% and 90%)
            const mintPos = Math.max(5, Math.min(90, basePos + mintOffset));
            const neutralPos = Math.max(5, Math.min(90, basePos + neutralOffset));
            const burnPos = Math.max(5, Math.min(90, basePos + burnOffset));

            mintRacer.style.left = `${mintPos}%`;
            neutralRacer.style.left = `${neutralPos}%`;
            burnRacer.style.left = `${burnPos}%`;

            // If near end (95%+), determine winner and show celebration at 98%
            if (progress >= 0.95) {
                // Remove winner from all first
                mintRacer.classList.remove('winner');
                neutralRacer.classList.remove('winner');
                burnRacer.classList.remove('winner');

                let winner;
                if (score <= 40) {
                    mintRacer.classList.add('winner');
                    winner = 'MINT';
                } else if (score >= 60) {
                    burnRacer.classList.add('winner');
                    winner = 'BURN';
                } else {
                    neutralRacer.classList.add('winner');
                    winner = 'NEUTRAL';
                }

                // Show celebration at 98% (only once per cycle)
                if (progress >= 0.98 && !window.celebrationShown) {
                    console.log(' Showing celebration! Winner:', winner, 'Score:', score);
                    window.celebrationShown = true;
                    showWinnerCelebration(winner);
                }
            } else {
                // Reset celebration flag when progress resets
                window.celebrationShown = false;
            }
        }

        // Show race winner with animation and celebration
        function showRaceWinner(result) {
            const mintRacer = document.getElementById('mintRacer');
            const neutralRacer = document.getElementById('neutralRacer');
            const burnRacer = document.getElementById('burnRacer');

            if (!mintRacer || !neutralRacer || !burnRacer) return;

            // Move winner to finish line
            if (result === 'MINT') {
                mintRacer.style.left = '90%';
                mintRacer.classList.add('winner');
            } else if (result === 'BURN') {
                burnRacer.style.left = '90%';
                burnRacer.classList.add('winner');
            } else {
                neutralRacer.style.left = '90%';
                neutralRacer.classList.add('winner');
            }

            // Show winner celebration overlay
            showWinnerCelebration(result);
        }

        // Show winner celebration overlay
        function showWinnerCelebration(result) {
            const overlay = document.getElementById('raceWinnerOverlay');
            const badge = document.getElementById('winnerBadge');
            const icon = document.getElementById('winnerIcon');
            const action = document.getElementById('winnerAction');

            if (!overlay || !badge || !icon || !action) return;

            // Set winner info
            badge.className = 'winner-badge ' + result.toLowerCase();
            action.textContent = result;

            if (result === 'MINT') {
                icon.textContent = '';
            } else if (result === 'BURN') {
                icon.textContent = '';
            } else {
                icon.textContent = '';
            }

            // Show overlay
            overlay.classList.add('active');
        }

        // Hide winner celebration
        function hideWinnerCelebration() {
            const overlay = document.getElementById('raceWinnerOverlay');
            if (overlay) overlay.classList.remove('active');
        }

        // Reset race for new cycle
        function resetCoinRace() {
            currentRaceScore = 50;
            currentCycleProgress = 0;
            const raceScoreEl = document.getElementById('raceScore');
            if (raceScoreEl) raceScoreEl.textContent = '50';

            const mintRacer = document.getElementById('mintRacer');
            const neutralRacer = document.getElementById('neutralRacer');
            const burnRacer = document.getElementById('burnRacer');

            if (mintRacer) { mintRacer.style.left = '5%'; mintRacer.classList.remove('winner'); }
            if (neutralRacer) { neutralRacer.style.left = '5%'; neutralRacer.classList.remove('winner'); }
            if (burnRacer) { burnRacer.style.left = '5%'; burnRacer.classList.remove('winner'); }

            // Hide winner celebration overlay
            hideWinnerCelebration();
        }

        // Web3 / Contract variables
        let web3Provider = null;
        let web3Signer = null;
        let tokenContract = null;
        let gameContract = null;
        let userTokenBalance = 0;
        let currentBlockchainRoundId = null; // Track blockchain round for result checking
        let reportedRounds = new Set(); // Prevent duplicate result reporting

        // Local timer for smooth countdown (prevents jumping)
        let localTimerValue = 0;
        let localTimerMode = 'OPEN'; // 'OPEN' or 'NEXT'
        let lastServerSync = 0;

        // Load real SCNDL balance from blockchain
        async function loadTokenBalance() {
            if (!tokenContract || !walletAddress) {
                console.log('loadTokenBalance: No contract or wallet');
                return;
            }
            try {
                console.log('loadTokenBalance: Fetching from blockchain...');
                const balance = await tokenContract.balanceOf(walletAddress);
                userTokenBalance = Number(ethers.formatEther(balance));
                console.log('loadTokenBalance: Got balance =', userTokenBalance);
                document.getElementById('userBalance').textContent = userTokenBalance.toLocaleString();
            } catch (error) {
                console.error('Error loading token balance:', error);
                // Don't change display on error - keep previous value or 0
            }
        }

        function openRules() { document.getElementById('rulesModal').classList.add('active'); }
        function closeRules() { document.getElementById('rulesModal').classList.remove('active'); }

        function openLastCycle() {
            if (!lastCycleData) return;
            document.getElementById('modalCycleId').textContent = lastCycleData.id;
            const actionEl = document.getElementById('modalCycleAction');
            actionEl.textContent = lastCycleData.action;
            actionEl.className = lastCycleData.action.toLowerCase();
            document.getElementById('modalCycleScore').textContent = lastCycleData.averageScore;
            document.getElementById('modalCycleRate').textContent = lastCycleData.ratePercentage;

            const listEl = document.getElementById('modalArticlesList');
            if (lastCycleData.articles.length === 0) {
                listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">No articles in this cycle</p>';
            } else {
                listEl.innerHTML = lastCycleData.articles.map(a => `
                    <div class="article-item">
                        <div class="article-title">${a.title}</div>
                        <div class="article-meta">
                            <span>${a.source || a.category}</span>
                            <span class="article-score">Score: ${a.score}</span>
                        </div>
                    </div>
                `).join('');
            }
            document.getElementById('lastCycleModal').classList.add('active');
        }

        function closeLastCycle() { document.getElementById('lastCycleModal').classList.remove('active'); }

        // Load real pool data from blockchain contract
        async function loadPoolFromContract() {
            if (!gameContract) {
                poolData = { mint: 0, neutral: 0, burn: 0 };
                updatePoolDisplay();
                return;
            }
            try {
                const round = await gameContract.getCurrentRound();
                const roundId = Number(round.id);

                // Check if round changed - get previous round result
                if (currentBlockchainRoundId !== null && currentBlockchainRoundId !== roundId) {
                    // Round changed! Check result for previous round
                    if (myVote) {
                        checkMyResult(currentBlockchainRoundId);
                    }
                    // Reset vote state for new round
                    myVote = null;
                    myBetAmount = 0;
                    document.querySelectorAll('.vote-btn').forEach(btn => btn.classList.remove('selected'));
                    document.getElementById('yourBet').style.display = 'none';

                    // Update round ID FIRST
                    currentBlockchainRoundId = roundId;

                    // Reset pool to 0 - new round starts fresh
                    poolData = { mint: 0, neutral: 0, burn: 0 };
                    updatePoolDisplay();
                    return; // Don't load old data, next call will get fresh data
                }

                currentBlockchainRoundId = roundId;

                // Load current round pool data
                poolData = {
                    mint: Number(ethers.formatEther(round.mintPool)),
                    neutral: Number(ethers.formatEther(round.neutralPool)),
                    burn: Number(ethers.formatEther(round.burnPool))
                };
                updatePoolDisplay();
            } catch (error) {
                console.error('Error loading pool:', error);
            }
        }

        // Toggle wallet connect/disconnect
        function toggleWallet() {
            if (walletAddress) {
                disconnectWallet();
            } else {
                connectWallet();
            }
        }

        // Disconnect wallet
        function disconnectWallet() {
            walletAddress = null;
            web3Provider = null;
            web3Signer = null;
            tokenContract = null;
            gameContract = null;
            userTokenBalance = 0;
            myVote = null;
            myBetAmount = 0;
            poolData = { mint: 0, neutral: 0, burn: 0 };

            document.getElementById('connectWallet').textContent = 'Connect Wallet';
            document.getElementById('connectWallet').style.background = '';
            document.getElementById('userBalance').textContent = '0';
            document.getElementById('userWon').textContent = '0';
            document.getElementById('userLost').textContent = '0';
            document.getElementById('winRate').textContent = '0%';
            document.getElementById('yourBet').style.display = 'none';
            document.querySelectorAll('.vote-btn').forEach(btn => btn.classList.remove('selected'));
            updatePoolDisplay();
        }

        function updatePoolDisplay() {
            // Pool data comes from blockchain - already includes all bets
            const total = poolData.mint + poolData.neutral + poolData.burn;
            document.getElementById('poolTotal').textContent = total.toLocaleString() + ' $SCNDL';

            document.getElementById('poolMint').textContent = poolData.mint;
            document.getElementById('poolNeutral').textContent = poolData.neutral;
            document.getElementById('poolBurn').textContent = poolData.burn;

            // Update bar widths
            if (total > 0) {
                const mintW = (poolData.mint / total * 100);
                const neutralW = (poolData.neutral / total * 100);
                const burnW = (poolData.burn / total * 100);

                document.getElementById('poolBarMint').style.width = mintW + '%';
                document.getElementById('poolBarNeutral').style.width = neutralW + '%';
                document.getElementById('poolBarBurn').style.width = burnW + '%';
            }
        }

        let isConnecting = false; // Guard against double-clicks

        async function connectWallet() {
            // Prevent double-clicks
            if (isConnecting) {
                return; // Already connecting, ignore
            }

            // Check for MetaMask
            if (typeof window.ethereum === 'undefined') {
                alert('Please install MetaMask to use this app!');
                return;
            }

            isConnecting = true;
            try {
                // Try wallet_requestPermissions first (shows account picker)
                // Fall back to eth_requestAccounts if pending
                let accounts;
                try {
                    await window.ethereum.request({
                        method: 'wallet_requestPermissions',
                        params: [{ eth_accounts: {} }]
                    });
                    accounts = await window.ethereum.request({ method: 'eth_accounts' });
                } catch (permError) {
                    // If pending or rejected, fall back to simple request
                    if (permError.code === -32002 || permError.code === 4001) {
                        accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    } else {
                        throw permError;
                    }
                }
                walletAddress = accounts[0];

                // Check/switch network to Base Sepolia
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                if (chainId !== WEB3_CONFIG.network.chainIdHex) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: WEB3_CONFIG.network.chainIdHex }]
                        });
                    } catch (switchError) {
                        // Network not added, add it
                        if (switchError.code === 4902) {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: WEB3_CONFIG.network.chainIdHex,
                                    chainName: WEB3_CONFIG.network.name,
                                    rpcUrls: [WEB3_CONFIG.network.rpcUrl],
                                    blockExplorerUrls: [WEB3_CONFIG.network.explorer],
                                    nativeCurrency: WEB3_CONFIG.network.currency
                                }]
                            });
                        }
                    }
                }

                // Initialize ethers provider and contracts
                web3Provider = new ethers.BrowserProvider(window.ethereum);
                web3Signer = await web3Provider.getSigner();
                tokenContract = new ethers.Contract(WEB3_CONFIG.contracts.token, WEB3_CONFIG.tokenABI, web3Signer);
                gameContract = new ethers.Contract(WEB3_CONFIG.contracts.game, WEB3_CONFIG.gameABI, web3Signer);

                // Update button text and style (click again to disconnect)
                document.getElementById('connectWallet').textContent = walletAddress.slice(0, 6) + '...' + walletAddress.slice(-4);
                document.getElementById('connectWallet').style.background = 'linear-gradient(135deg, #00ff88, #00cc66)';

                // Reset wallet balance to 0 before loading (will be updated from blockchain)
                document.getElementById('userBalance').textContent = '0';

                // Save session to localStorage
                localStorage.setItem('scandals_wallet', walletAddress);
                localStorage.setItem('scandals_lastActive', Date.now().toString());

                // Load data independently (don't let one failure block others)
                try { await loadTokenBalance(); } catch (e) { console.log('Balance load error:', e); }
                try { await loadV2GameBalance(); } catch (e) { console.log('V2 game balance error:', e); }
                try { await loadV2RoundInfo(); } catch (e) { console.log('V2 round info error:', e); }
                // loadUserStats removed - stats now loaded via loadV2GameBalance
                try { await updateGameStatus(); } catch (e) { console.log('Status update error:', e); }
                try { await restoreCurrentBet(); } catch (e) { console.log('Bet restore error:', e); }
                try { await loadBetHistory(); } catch (e) { console.log('Bet history load error:', e); }

                // Show game balance panel when wallet connected
                document.getElementById('gameBalancePanel').style.display = 'block';

            } catch (error) {
                console.error('Wallet connection failed:', error);
                const errorMsg = error?.message || error?.reason || String(error);
                if (!errorMsg.includes('pending') && !errorMsg.includes('rejected')) {
                    alert('Failed to connect wallet: ' + errorMsg);
                }
            } finally {
                isConnecting = false;
            }
        }

        // Setup MetaMask event listeners (call once on page load)
        function setupWalletListeners() {
            if (typeof window.ethereum !== 'undefined') {
                // Listen for account changes
                window.ethereum.on('accountsChanged', async (accounts) => {
                    if (accounts.length === 0) {
                        // User disconnected from MetaMask
                        disconnectWallet();
                    } else if (walletAddress && accounts[0].toLowerCase() !== walletAddress.toLowerCase()) {
                        // User switched accounts - update to new account
                        walletAddress = accounts[0];
                        web3Signer = await web3Provider.getSigner();
                        tokenContract = new ethers.Contract(WEB3_CONFIG.contracts.token, WEB3_CONFIG.tokenABI, web3Signer);
                        gameContract = new ethers.Contract(WEB3_CONFIG.contracts.game, WEB3_CONFIG.gameABI, web3Signer);

                        document.getElementById('connectWallet').textContent = walletAddress.slice(0, 6) + '...' + walletAddress.slice(-4);
                        await loadTokenBalance();
                        await loadUserStats();
                    }
                });

                // Listen for network changes
                window.ethereum.on('chainChanged', () => {
                    window.location.reload();
                });
            }
        }

        // Initialize listeners on page load
        setupWalletListeners();

        async function loadUserStats() {
            if (!walletAddress) return;

            // Balance comes from blockchain (loadTokenBalance)
            // Other stats come from server (wins/losses from game history)
            try {
                const res = await fetch(`/api/user-stats/${walletAddress}`);
                const data = await res.json();
                // Balance is loaded from blockchain, not from server
                document.getElementById('userWon').textContent = (data.totalWon || 0).toLocaleString();
                document.getElementById('userLost').textContent = (data.totalLost || 0).toLocaleString();

                const wins = data.wins || 0;
                const total = (data.wins || 0) + (data.losses || 0);
                const rate = total > 0 ? Math.round((wins / total) * 100) : 0;
                document.getElementById('winRate').textContent = rate + '%';
            } catch (error) {
                console.error('Load user stats error:', error);
            }
        }

        async function updateGameStatus() {
            try {
                const url = walletAddress ? `/api/game-status?wallet=${walletAddress}` : '/api/game-status';
                const res = await fetch(url);
                const data = await res.json();

                // Detect cycle change - check result and reset
                if (lastCycleId && lastCycleId !== data.cycleId) {
                    // Show result popup if had bet
                    if (myVote) {
                        checkLastBetResult(lastCycleId);
                    }
                    // Reset UI for new cycle
                    myVote = null;
                    myBetAmount = 0;
                    document.querySelectorAll('.vote-btn').forEach(btn => btn.classList.remove('selected'));
                    document.getElementById('yourBet').style.display = 'none';
                    document.getElementById('pendingBetInfo').classList.remove('active');

                    // Refresh last cycle data after delay (allow MongoDB to save)
                    setTimeout(() => loadLastCycleData(), 2000);

                    // Show winner celebration briefly if not shown yet
                    if (!window.celebrationShown && currentRaceScore !== 50) {
                        let winner = 'NEUTRAL';
                        if (currentRaceScore <= 40) winner = 'MINT';
                        else if (currentRaceScore >= 60) winner = 'BURN';
                        console.log(' Cycle ended! Winner:', winner, 'Score:', currentRaceScore);
                        showWinnerCelebration(winner);
                        // Hide celebration after 3 seconds
                        setTimeout(() => hideWinnerCelebration(), 3000);
                    }

                    // Reset coin race immediately for new round
                    resetCoinRace();

                    // Refresh balance and history
                    if (walletAddress) {
                        loadTokenBalance();
                        loadV2GameBalance();
                        setTimeout(() => loadBetHistory(), 2000);
                    }
                }
                lastCycleId = data.cycleId;

                // ===== USE SERVER DATA FOR BET STATE (single source of truth) =====
                if (data.userPendingBet) {
                    // User has pending bet for this round from server
                    myVote = data.userPendingBet.prediction;
                    myBetAmount = data.userPendingBet.amount || BET_AMOUNT;

                    // Update UI to show bet is placed
                    document.querySelectorAll('.vote-btn').forEach(btn => btn.classList.remove('selected'));
                    const btnId = `vote${myVote.charAt(0).toUpperCase() + myVote.slice(1).toLowerCase()}`;
                    document.getElementById(btnId)?.classList.add('selected');

                    document.getElementById('yourBet').style.display = 'block';
                    document.getElementById('yourBetAmount').textContent = myBetAmount;
                    document.getElementById('yourBetChoice').textContent = myVote;
                } else if (data.userVote && !myVote) {
                    // Legacy vote check (fallback)
                    myVote = data.userVote;
                    myBetAmount = BET_AMOUNT;
                    const btnId = `vote${myVote.charAt(0).toUpperCase() + myVote.slice(1).toLowerCase()}`;
                    document.getElementById(btnId)?.classList.add('selected');
                    document.getElementById('yourBet').style.display = 'block';
                    document.getElementById('yourBetAmount').textContent = BET_AMOUNT;
                    document.getElementById('yourBetChoice').textContent = myVote;
                }

                // ===== USE SERVER POOL DATA =====
                if (data.pools && typeof data.pools.mint === 'number') {
                    const total = data.poolTotal || (data.pools.mint + data.pools.neutral + data.pools.burn);
                    const poolTotalEl = document.getElementById('poolTotal');
                    if (poolTotalEl && total >= 0) poolTotalEl.textContent = total.toLocaleString() + ' $SCNDL';

                    if (total > 0) {
                        const mintPct = (data.pools.mint / total * 100).toFixed(0);
                        const neutralPct = (data.pools.neutral / total * 100).toFixed(0);
                        const burnPct = (data.pools.burn / total * 100).toFixed(0);

                        const barMint = document.getElementById('poolBarMint');
                        const barNeutral = document.getElementById('poolBarNeutral');
                        const barBurn = document.getElementById('poolBarBurn');
                        if (barMint) barMint.style.width = mintPct + '%';
                        if (barNeutral) barNeutral.style.width = neutralPct + '%';
                        if (barBurn) barBurn.style.width = burnPct + '%';

                        const amtMint = document.getElementById('poolMint');
                        const amtNeutral = document.getElementById('poolNeutral');
                        const amtBurn = document.getElementById('poolBurn');
                        if (amtMint) amtMint.textContent = data.pools.mint.toLocaleString();
                        if (amtNeutral) amtNeutral.textContent = data.pools.neutral.toLocaleString();
                        if (amtBurn) amtBurn.textContent = data.pools.burn.toLocaleString();
                    } else {
                        const barMint = document.getElementById('poolBarMint');
                        const barNeutral = document.getElementById('poolBarNeutral');
                        const barBurn = document.getElementById('poolBarBurn');
                        if (barMint) barMint.style.width = '33%';
                        if (barNeutral) barNeutral.style.width = '34%';
                        if (barBurn) barBurn.style.width = '33%';

                        const amtMint = document.getElementById('poolMint');
                        const amtNeutral = document.getElementById('poolNeutral');
                        const amtBurn = document.getElementById('poolBurn');
                        if (amtMint) amtMint.textContent = '0';
                        if (amtNeutral) amtNeutral.textContent = '0';
                        if (amtBurn) amtBurn.textContent = '0';
                    }
                }

                // ===== UPDATE COIN RACE based on Oracle score and cycle time =====
                if (typeof data.cycleProgress === 'number' && typeof data.averageScore === 'number') {
                    // Use Oracle score and cycle progress for race
                    updateCoinRace(data.cycleProgress, data.averageScore, data.articlesCount || 0);
                } else if (typeof data.cycleTimeRemaining === 'number' && typeof data.cycleTotal === 'number') {
                    // Fallback: calculate progress from time
                    const progress = 1 - (data.cycleTimeRemaining / data.cycleTotal);
                    const score = data.averageScore || 50;
                    updateCoinRace(Math.max(0, Math.min(1, progress)), score, data.articlesCount || 0);
                }

                document.getElementById('currentCycle').textContent = '#' + data.cycleId;
                document.getElementById('articlesCount').textContent = data.articlesCount;

                const timerEl = document.getElementById('votingTimer');
                if (data.votingOpen) {
                    localTimerValue = Math.floor(data.votingTimeRemaining / 1000);
                    localTimerMode = 'OPEN';
                    timerEl.classList.remove('closed');
                } else {
                    localTimerValue = Math.floor((data.cycleTimeRemaining || 0) / 1000);
                    localTimerMode = 'NEXT';
                    timerEl.classList.add('closed');
                }
                lastServerSync = Date.now();

                // ===== VOTE BUTTON STATE (use server pendingBet as truth) =====
                let canVote = false;
                const gameBalText = document.getElementById('gameBalance').textContent || '0';
                const currentGameBalance = Number(gameBalText.replace(/[^0-9.-]/g, '')) || 0;

                // Can vote if: wallet connected, voting open, has balance, NO pending bet
                const hasPendingBet = !!data.userPendingBet || !!myVote;
                if (walletAddress && data.votingOpen && currentGameBalance >= BET_AMOUNT && !hasPendingBet) {
                    canVote = true;
                }

                document.getElementById('arenaMint').disabled = !canVote;
                document.getElementById('arenaNeutral').disabled = !canVote;
                document.getElementById('arenaBurn').disabled = !canVote;
            } catch (error) {
                console.log('updateGameStatus error:', error);
            }
        }

        // V2: Instant bet via API (no blockchain call per bet!)
        async function vote(choice) {
            if (!walletAddress) {
                showMessage('Connect wallet first!', 'error');
                return;
            }

            // DISABLE BUTTONS IMMEDIATELY to prevent double-clicks
            document.getElementById('arenaMint').disabled = true;
            document.getElementById('arenaNeutral').disabled = true;
            document.getElementById('arenaBurn').disabled = true;

            try {
                // Check game balance from API afresh
                const balanceData = await GameAPI.getBalance(walletAddress);

                if (balanceData.balance < BET_AMOUNT) {
                    showMessage(`Insufficient game balance! Need ${BET_AMOUNT} SCNDL. You have ${balanceData.balance}. Deposit first!`, 'error');
                    updateGameStatus(); // Re-enable buttons
                    return;
                }

                // Note: Server will check if already bet - don't duplicate check here 
                // (frontend currentCycleId may be stale)

                showMessage('Placing bet...', 'info');

                // V2: Instant API call - NO MetaMask popup!
                const result = await GameAPI.placeBet(walletAddress, choice, BET_AMOUNT);

                if (!result.success) {
                    showMessage(result.error || 'Bet failed', 'error');
                    setTimeout(updateGameStatus, 500); // Re-enable on error
                    return;
                }

                // Success - KEEP BUTTONS DISABLED (already bet this round)
                myVote = choice;
                myBetAmount = BET_AMOUNT;

                showMessage(` Bet placed: ${BET_AMOUNT} SCNDL on ${choice}`, 'success');
                document.querySelectorAll('.vote-btn').forEach(btn => btn.classList.remove('selected'));
                document.getElementById(`vote${choice.charAt(0) + choice.slice(1).toLowerCase()}`).classList.add('selected');

                // Show bet info
                document.getElementById('yourBet').style.display = 'block';
                document.getElementById('yourBetAmount').textContent = BET_AMOUNT;
                document.getElementById('yourBetChoice').textContent = choice;

                // Update game balance display
                document.getElementById('gameBalance').textContent = result.newBalance.toLocaleString() + ' SCNDL';

                // Show pending bet info
                document.getElementById('pendingBetInfo').classList.add('active');
                document.getElementById('pendingBetAmount').textContent = BET_AMOUNT;
                document.getElementById('pendingBetChoice').textContent = choice;

                // Refresh V2 round info for pool display
                loadV2RoundInfo();

                // Buttons stay disabled until next round!

            } catch (error) {
                console.error('V2 Bet error:', error);
                showMessage('Bet failed: ' + (error.message || 'Unknown error'), 'error');
                setTimeout(updateGameStatus, 1000); // Re-enable on error
            }
        }

        // V2: Load game balance from API
        async function loadV2GameBalance() {
            if (!walletAddress) return;
            try {
                const data = await GameAPI.getBalance(walletAddress);
                document.getElementById('gameBalance').textContent = data.balance.toLocaleString() + ' SCNDL';
                document.getElementById('gameBalancePanel').style.display = 'block';

                // Show pending bet if exists (trust server data, don't compare with local roundId)
                if (data.pendingBet && data.pendingBet.roundId) {
                    myVote = data.pendingBet.prediction;
                    document.getElementById('pendingBetInfo').classList.add('active');
                    document.getElementById('pendingBetAmount').textContent = data.pendingBet.amount;
                    document.getElementById('pendingBetChoice').textContent = data.pendingBet.prediction;

                    // Also show in "Your Bet" section
                    document.getElementById('yourBet').style.display = 'block';
                    document.getElementById('yourBetAmount').textContent = data.pendingBet.amount;
                    document.getElementById('yourBetChoice').textContent = data.pendingBet.prediction;

                    // Disable vote buttons since there's a pending bet
                    document.getElementById('arenaMint').disabled = true;
                    document.getElementById('arenaNeutral').disabled = true;
                    document.getElementById('arenaBurn').disabled = true;
                } else {
                    // No pending bet - reset UI
                    myVote = null;
                    document.getElementById('pendingBetInfo').classList.remove('active');
                    document.getElementById('yourBet').style.display = 'none';
                }

                // Update stats
                if (data.stats) {
                    console.log('Updating stats:', data.stats);
                    document.getElementById('userWon').textContent = data.stats.totalWon.toLocaleString();
                    document.getElementById('userLost').textContent = data.stats.totalLost.toLocaleString();
                    document.getElementById('winRate').textContent = data.stats.winRate + '%';
                } else {
                    console.log('No stats in response!');
                }
            } catch (e) {
                console.log('Load V2 balance error:', e);
            }
        }

        // V2: Load round info from API
        async function loadV2RoundInfo() {
            try {
                const data = await GameAPI.getRound();

                // Update pool display
                poolData = {
                    mint: data.pools?.mint || 0,
                    neutral: data.pools?.neutral || 0,
                    burn: data.pools?.burn || 0
                };
                updatePoolDisplay();
                document.getElementById('poolTotal').textContent = data.totalPool.toLocaleString() + ' $SCNDL';
            } catch (e) {
                console.log('Load V2 round error:', e);
            }
        }

        // Deposit modal state
        let depositMode = 'deposit'; // 'deposit' or 'withdraw'

        // V2: Open styled deposit modal
        function openDepositModal() {
            try {
                depositMode = 'deposit';
                const title = document.getElementById('depositModalTitle');
                const btn = document.getElementById('depositConfirmBtn');
                const note = document.getElementById('depositNote');
                const walletBal = document.getElementById('modalWalletBalance');

                if (!title || !btn) {
                    console.error('Critical: Modal elements not found');
                    alert('Error: Modal elements missing');
                    return;
                }

                title.textContent = 'DEPOSIT SCNDL';
                btn.textContent = 'DEPOSIT';
                btn.classList.remove('withdraw');
                note.textContent = 'Minimum: 1,000 SCNDL';
                walletBal.textContent = userTokenBalance.toLocaleString() + ' SCNDL';

                // Get game balance
                const gameBalEl = document.getElementById('gameBalance');
                document.getElementById('modalGameBalance').textContent = gameBalEl?.textContent || '0 SCNDL';

                document.getElementById('depositAmountInput').value = '';
                document.getElementById('depositModal').classList.add('active');
                console.log('Deposit modal opened');
            } catch (e) {
                console.error('Error opening deposit modal:', e);
            }
        }

        // V2: Open styled withdraw modal
        function openWithdrawModal() {
            depositMode = 'withdraw';
            document.getElementById('depositModalTitle').textContent = 'WITHDRAW SCNDL';
            document.getElementById('depositConfirmBtn').textContent = 'WITHDRAW';
            document.getElementById('depositConfirmBtn').classList.add('withdraw');
            document.getElementById('depositNote').textContent = 'Withdraw to your wallet';
            document.getElementById('modalWalletBalance').textContent = userTokenBalance.toLocaleString() + ' SCNDL';

            const gameBalEl = document.getElementById('gameBalance');
            document.getElementById('modalGameBalance').textContent = gameBalEl?.textContent || '0 SCNDL';

            document.getElementById('depositAmountInput').value = '';
            document.getElementById('depositModal').classList.add('active');
        }

        function closeDepositModal() {
            document.getElementById('depositModal').classList.remove('active');
        }

        // Result Popup - Show win/lose after round ends
        function showRoundResult(won, amount, prediction, actualResult) {
            const popup = document.getElementById('resultPopup');
            const icon = document.getElementById('resultIcon');
            const text = document.getElementById('resultText');
            const points = document.getElementById('resultPoints');
            const streak = document.getElementById('resultStreak');

            if (won) {
                icon.textContent = '';
                text.textContent = 'YOU WON!';
                text.style.color = 'var(--accent-green)';
                points.textContent = `+${amount.toLocaleString()} SCNDL`;
                points.style.color = 'var(--accent-green)';
            } else {
                icon.textContent = '';
                text.textContent = 'YOU LOST';
                text.style.color = 'var(--accent-red)';
                points.textContent = `-${amount.toLocaleString()} SCNDL`;
                points.style.color = 'var(--accent-red)';
            }

            streak.textContent = `You bet ${prediction}  Result: ${actualResult}`;

            popup.classList.add('active');

            // Auto-close after 4 seconds
            setTimeout(() => {
                popup.classList.remove('active');
            }, 4000);
        }

        function closeResultPopup() {
            document.getElementById('resultPopup').classList.remove('active');
        }

        // Check last bet result after cycle change
        async function checkLastBetResult(previousCycleId) {
            if (!walletAddress) return;

            try {
                // Get the completed cycle result
                const res = await fetch('/api/news');
                const data = await res.json();

                if (data.completedCycles && data.completedCycles.length > 0) {
                    const lastCycle = data.completedCycles.find(c => c.id === previousCycleId);

                    if (lastCycle && betHistoryData.length > 0) {
                        // Find bet for this cycle
                        const myBet = betHistoryData.find(b => b.roundId === previousCycleId);

                        if (myBet) {
                            const actualResult = (lastCycle.action || 'NEUTRAL').toUpperCase();
                            const won = myBet.prediction === actualResult;
                            const amount = won ? (myBet.payout || myBet.amount) : myBet.amount;

                            showRoundResult(won, amount, myBet.prediction, actualResult);
                        }
                    }
                }
            } catch (e) {
                console.log('Check last bet result error:', e);
            }
        }

        // Rules Modal
        function openRules() {
            document.getElementById('rulesModal').classList.add('active');
        }

        function closeRules() {
            document.getElementById('rulesModal').classList.remove('active');
        }

        // Last Cycle Modal

        async function openLastCycle() {
            console.log('openLastCycle called, data:', lastCycleData);

            // If no data, try to load it first
            if (!lastCycleData) {
                console.log('No last cycle data, fetching...');
                await loadLastCycleData();
            }

            if (!lastCycleData) {
                console.log('Still no data after fetch');
                alert('No completed cycles yet');
                return;
            }

            document.getElementById('modalCycleId').textContent = lastCycleData.id;
            document.getElementById('modalCycleAction').textContent = lastCycleData.action || 'NEUTRAL';
            document.getElementById('modalCycleScore').textContent = (lastCycleData.averageScore || 50).toFixed(1);
            document.getElementById('modalCycleRate').textContent = lastCycleData.ratePercentage || '0%';

            // Color the action
            const actionEl = document.getElementById('modalCycleAction');
            actionEl.className = '';
            if (lastCycleData.action === 'MINT') actionEl.style.color = 'var(--accent-green)';
            else if (lastCycleData.action === 'BURN') actionEl.style.color = 'var(--accent-red)';
            else actionEl.style.color = 'var(--accent-cyan)';

            // Render articles list
            const articlesEl = document.getElementById('modalArticlesList');
            if (lastCycleData.articles && lastCycleData.articles.length > 0) {
                articlesEl.innerHTML = lastCycleData.articles.map(article => {
                    const scoreColor = article.score >= 60 ? 'var(--accent-green)' :
                        article.score <= 40 ? 'var(--accent-red)' : 'var(--accent-cyan)';
                    return `
                        <div style="padding: 0.5rem; background: rgba(0,0,0,0.3); border-radius: 6px; margin-bottom: 0.4rem; font-size: 0.75rem;">
                            <div style="color: var(--text-primary); margin-bottom: 0.2rem;">${article.title || 'Untitled'}</div>
                            <div style="display: flex; justify-content: space-between; color: var(--text-secondary);">
                                <span>${article.category || 'news'}</span>
                                <span style="color: ${scoreColor}; font-family: 'Orbitron';">Score: ${article.score}</span>
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                articlesEl.innerHTML = '<p class="text-secondary" style="text-align: center; font-size: 0.8rem;">No articles in this cycle</p>';
            }

            document.getElementById('lastCycleModal').classList.add('active');
        }

        function closeLastCycle() {
            document.getElementById('lastCycleModal').classList.remove('active');
        }

        // Result Popup Functions
        async function checkLastBetResult(prevCycleId) {
            if (!walletAddress) return;

            console.log('Checking result for cycle:', prevCycleId);

            // Wait for server to process results
            await new Promise(resolve => setTimeout(resolve, 2500));

            try {
                // Fetch updated bet history which includes the result
                const res = await fetch(`/api/v2/history/${walletAddress}`);
                const data = await res.json();

                if (!data.history || data.history.length === 0) return;

                // Find the bet for the previous cycle
                const bet = data.history.find(b => b.roundId === prevCycleId);
                if (!bet || bet.pending) return;

                // Show popup
                const popup = document.getElementById('resultPopup');
                const icon = document.getElementById('resultIcon');
                const title = document.getElementById('resultTitle');
                const amount = document.getElementById('resultAmount');

                popup.classList.remove('win', 'lose');

                if (bet.won) {
                    popup.classList.add('win');
                    icon.textContent = '';
                    title.textContent = 'YOU WON!';
                    amount.textContent = `+${bet.payout.toLocaleString()} SCNDL`;
                } else {
                    popup.classList.add('lose');
                    icon.textContent = '';
                    title.textContent = 'YOU LOST';
                    amount.textContent = `-${bet.amount.toLocaleString()} SCNDL`;
                }

                popup.classList.add('active');

                // Auto-close after 5 seconds
                setTimeout(() => {
                    popup.classList.remove('active');
                }, 5000);

            } catch (e) {
                console.log('Error checking bet result:', e);
            }
        }

        function closeResultPopup() {
            document.getElementById('resultPopup').classList.remove('active');
        }

        // Load Last Cycle Data
        async function loadLastCycleData() {
            try {
                const res = await fetch('/api/last-cycle');
                const data = await res.json();

                if (data.lastCycle) {
                    lastCycleData = data.lastCycle;

                    // Update button display
                    document.getElementById('lastCycleNumber').textContent = lastCycleData.id;

                    const resultEl = document.getElementById('lastCycleResult');
                    const panelEl = document.getElementById('lastCyclePanel');
                    const action = (lastCycleData.action || 'NEUTRAL').toUpperCase();
                    resultEl.textContent = action;

                    // Remove ALL color classes first
                    panelEl.classList.remove('mint', 'burn', 'neutral');

                    // Add correct color class based on action
                    if (action === 'MINT') {
                        panelEl.classList.add('mint');
                    } else if (action === 'BURN') {
                        panelEl.classList.add('burn');
                    } else {
                        panelEl.classList.add('neutral');
                    }

                    console.log('Last cycle loaded:', action, 'Panel classes:', panelEl.className);
                }
            } catch (e) {
                console.log('Load last cycle error:', e);
            }
        }

        // Load Bet History for player (preview and full list)
        let betHistoryData = [];

        async function loadBetHistory() {
            if (!walletAddress) {
                document.getElementById('betHistoryPanel').style.display = 'none';
                return;
            }

            document.getElementById('betHistoryPanel').style.display = 'block';

            try {
                const res = await fetch(`/api/v2/history/${walletAddress}`);
                const data = await res.json();
                betHistoryData = data.history || [];

                // Preview panel (show first 2-3 items)
                const previewEl = document.getElementById('betHistoryPreview');
                if (betHistoryData.length === 0) {
                    previewEl.innerHTML = '<p class="text-secondary" style="text-align: center; font-size: 0.65rem;">No bets yet</p>';
                } else {
                    // Preview panel shows first 5 items
                    previewEl.innerHTML = betHistoryData.slice(0, 5).map(bet => {
                        const statusClass = bet.won ? 'win' : (bet.pending ? 'pending' : 'lose');
                        const statusText = bet.won ? `+${bet.payout}` : (bet.pending ? '' : `-${bet.amount}`);
                        return `<div class="preview-item ${statusClass}"><span>#${bet.roundId} ${bet.prediction}</span><span>${statusText}</span></div>`;
                    }).join('');
                }
            } catch (e) {
                console.log('Load bet history error:', e);
            }
        }

        // Bet History Modal
        function openBetHistoryModal() {
            document.getElementById('betHistoryModal').classList.add('active');
            renderBetHistoryModal();
        }

        function closeBetHistoryModal() {
            document.getElementById('betHistoryModal').classList.remove('active');
        }

        function renderBetHistoryModal() {
            const listEl = document.getElementById('betHistoryList');
            if (betHistoryData.length === 0) {
                listEl.innerHTML = '<p class="text-secondary" style="text-align: center;">No bets yet</p>';
                return;
            }

            listEl.innerHTML = betHistoryData.slice(0, 20).map(bet => {
                const statusClass = bet.won ? 'win' : (bet.pending ? 'pending' : 'lose');
                const statusText = bet.won ? `+${bet.payout} SCNDL` : (bet.pending ? 'Pending' : `-${bet.amount} SCNDL`);
                const statusColor = bet.won ? 'var(--accent-green)' : (bet.pending ? 'var(--accent-cyan)' : 'var(--accent-red)');
                return `
                    <div class="leaderboard-item" style="border-left: 3px solid ${statusColor};">
                        <span>#${bet.roundId}</span>
                        <span>${bet.prediction}</span>
                        <span style="color: ${statusColor};">${statusText}</span>
                    </div>
                `;
            }).join('');
        }

        // Leaderboard Modal
        let leaderboardData = [];

        async function openLeaderboardModal() {
            document.getElementById('leaderboardModal').classList.add('active');
            document.getElementById('leaderboardSearch').value = '';
            await loadLeaderboard();
        }

        function closeLeaderboardModal() {
            document.getElementById('leaderboardModal').classList.remove('active');
        }

        async function loadLeaderboard() {
            const listEl = document.getElementById('leaderboardList');
            const previewEl = document.getElementById('leaderboardPreview');

            if (listEl) listEl.innerHTML = '<p class="text-secondary" style="text-align: center;">Loading...</p>';

            try {
                // Use V2 API for leaderboard (only real game results)
                const res = await fetch('/api/v2/leaderboard?sortBy=profit');
                const data = await res.json();
                leaderboardData = data.leaderboard || [];

                // Render full list in modal
                renderLeaderboard(leaderboardData);

                // Render preview (top 5 players)
                if (previewEl && leaderboardData.length > 0) {
                    previewEl.innerHTML = leaderboardData.slice(0, 5).map((player, index) => {
                        const rank = index + 1;
                        const wallet = player.wallet.slice(0, 6) + '...' + player.wallet.slice(-4);
                        const profit = player.profit || 0;
                        const profitColor = profit >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
                        const profitSign = profit >= 0 ? '+' : '';
                        return `<div class="preview-item"><span>#${rank} ${wallet}</span><span style="color: ${profitColor};">${profitSign}${profit.toLocaleString()}</span></div>`;
                    }).join('');
                } else if (previewEl) {
                    previewEl.innerHTML = '<p class="text-secondary" style="text-align: center; font-size: 0.65rem;">No players yet</p>';
                }
            } catch (e) {
                if (listEl) listEl.innerHTML = '<p class="text-secondary" style="text-align: center;">Error loading</p>';
                if (previewEl) previewEl.innerHTML = '<p class="text-secondary" style="text-align: center; font-size: 0.65rem;">Error</p>';
            }
        }

        function renderLeaderboard(data) {
            const listEl = document.getElementById('leaderboardList');

            if (!data || data.length === 0) {
                listEl.innerHTML = '<p class="text-secondary" style="text-align: center;">No players yet</p>';
                return;
            }

            listEl.innerHTML = data.map((player, index) => {
                const rank = index + 1;
                const isTop3 = rank <= 3 ? 'top-3' : '';
                const wallet = player.wallet.slice(0, 6) + '...' + player.wallet.slice(-4);
                const profit = player.profit || 0;
                const profitColor = profit >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
                const profitSign = profit >= 0 ? '+' : '';
                return `
                    <div class="leaderboard-item ${isTop3}">
                        <span class="leaderboard-rank">#${rank}</span>
                        <span class="leaderboard-wallet">${wallet}</span>
                        <span class="leaderboard-balance" style="color: ${profitColor};">${profitSign}${profit.toLocaleString()} SCNDL</span>
                    </div>
                `;
            }).join('');
        }

        function filterLeaderboard(query) {
            if (!query) {
                renderLeaderboard(leaderboardData);
                return;
            }

            const q = query.toLowerCase();
            const filtered = leaderboardData.filter(p =>
                p.wallet.toLowerCase().includes(q) ||
                p.wallet.slice(-4).toLowerCase().includes(q)
            );
            renderLeaderboard(filtered);
        }

        function setDepositAmount(amount) {
            document.getElementById('depositAmountInput').value = amount;
        }

        function setMaxDeposit() {
            if (depositMode === 'deposit') {
                document.getElementById('depositAmountInput').value = Math.floor(userTokenBalance);
            } else {
                // For withdraw - use game balance
                const gameBalText = document.getElementById('modalGameBalance').textContent;
                const gameBalance = parseInt(gameBalText.replace(/[^\d]/g, '')) || 0;
                document.getElementById('depositAmountInput').value = gameBalance;
            }
        }

        async function confirmDeposit() {
            const amount = Number(document.getElementById('depositAmountInput').value);

            if (!amount || isNaN(amount) || amount <= 0) {
                showMessage('Enter a valid amount', 'error');
                return;
            }

            closeDepositModal();

            if (depositMode === 'deposit') {
                if (amount < 1000) {
                    showMessage('Minimum deposit is 1,000 SCNDL', 'error');
                    return;
                }
                await depositToGame(amount);
            } else {
                await withdrawFromGame(amount);
            }
        }

        // Load V2 game balance from server
        async function loadV2GameBalance() {
            if (!walletAddress) return;

            try {
                const data = await GameAPI.getBalance(walletAddress);
                const gameBalance = data.balance || 0;

                // Update any game balance displays
                const gameBalanceEl = document.getElementById('gameBalance');
                if (gameBalanceEl) {
                    gameBalanceEl.textContent = gameBalance.toLocaleString();
                }

                // Also update user balance stat card
                // Update deposit modal game balance (NOT userBalance - that's wallet balance!)
                const modalGameBalance = document.getElementById('modalGameBalance');
                if (modalGameBalance) {
                    modalGameBalance.textContent = gameBalance.toLocaleString() + ' SCNDL';
                }

                console.log('Game balance loaded:', gameBalance);

                // Update stats
                if (data.stats) {
                    console.log('Updating stats:', data.stats);
                    document.getElementById('userWon').textContent = data.stats.totalWon.toLocaleString();
                    document.getElementById('userLost').textContent = data.stats.totalLost.toLocaleString();
                    document.getElementById('winRate').textContent = data.stats.winRate + '%';
                }

                return gameBalance;
            } catch (e) {
                console.error('Error loading game balance:', e);
                return 0;
            }
        }

        // V2: Deposit to game contract
        async function depositToGame(amount) {
            if (!gameContract || !tokenContract) {
                alert('Connect wallet first');
                return;
            }

            try {
                showMessage('Checking allowance...', 'info');
                const depositAmount = ethers.parseEther(amount.toString());

                // Check allowance
                const allowance = await tokenContract.allowance(walletAddress, WEB3_CONFIG.contracts.game);
                if (allowance < depositAmount) {
                    showMessage('Approve SCNDL in MetaMask...', 'info');
                    const approveTx = await tokenContract.approve(WEB3_CONFIG.contracts.game, ethers.parseEther('10000000'));
                    await approveTx.wait();
                }

                // Deposit
                showMessage('Confirm deposit in MetaMask...', 'info');
                const depositTx = await gameContract.deposit(depositAmount);
                showMessage('Waiting for confirmation...', 'info');
                await depositTx.wait();

                // Sync balance with server
                await GameAPI.syncBalance(walletAddress);
                await loadV2GameBalance();
                await loadTokenBalance();

                showMessage(` Deposited ${amount} SCNDL to game!`, 'success');
            } catch (error) {
                console.error('Deposit error:', error);
                showMessage('Deposit failed: ' + (error.reason || error.message), 'error');
            }
        }

        // V2: Withdraw from game contract
        async function withdrawFromGame(amount) {
            if (!gameContract) {
                alert('Connect wallet first');
                return;
            }

            try {
                showMessage('Confirm withdraw in MetaMask...', 'info');
                const withdrawAmount = ethers.parseEther(amount.toString());
                const withdrawTx = await gameContract.withdraw(withdrawAmount);

                showMessage('Waiting for confirmation...', 'info');
                await withdrawTx.wait();

                // Sync balance with server
                await GameAPI.syncBalance(walletAddress);
                await loadV2GameBalance();
                await loadTokenBalance();

                showMessage(` Withdrew ${amount} SCNDL from game!`, 'success');
            } catch (error) {
                console.error('Withdraw error:', error);
                showMessage('Withdraw failed: ' + (error.reason || error.message), 'error');
            }
        }

        function showResult(resultType, tokenAmount) {
            const popup = document.getElementById('resultPopup');
            const content = document.getElementById('resultContent');
            const icon = document.getElementById('resultIcon');
            const text = document.getElementById('resultText');
            const pts = document.getElementById('resultPoints');
            const stk = document.getElementById('resultStreak');

            if (resultType === 'refund') {
                content.className = 'result-content refund';
                icon.textContent = '';
                text.textContent = 'REFUND';
                pts.textContent = `+${tokenAmount} $SCNDL`;
                stk.textContent = 'No news this cycle - bet returned!';
            } else if (resultType === 'win') {
                content.className = 'result-content win';
                icon.textContent = '';
                text.textContent = 'WIN!';
                pts.textContent = `+${tokenAmount} $SCNDL`;
                stk.textContent = 'Congratulations!';
            } else {
                content.className = 'result-content lose';
                icon.textContent = '';
                text.textContent = 'LOSE';
                pts.textContent = `-${tokenAmount} $SCNDL`;
                stk.textContent = 'Better luck next time!';
            }

            popup.classList.add('active');
            setTimeout(() => popup.classList.remove('active'), 4000);
        }

        // Claim winnings from blockchain
        async function claimWinnings(roundId) {
            if (!gameContract || !walletAddress) {
                showMessage('Connect wallet first', 'error');
                return;
            }

            try {
                showMessage('Claiming winnings...', 'info');

                const tx = await gameContract.claimWinnings(roundId);
                showMessage('Waiting for confirmation...', 'info');
                await tx.wait();

                showMessage('Winnings claimed! ', 'success');
                await loadTokenBalance();
                await loadUserStats();
                await loadUnclaimedWinnings(); // Refresh unclaimed list
            } catch (error) {
                console.error('Claim error:', error);
                if (error.message && error.message.includes('Already claimed')) {
                    showMessage('Already claimed!', 'error');
                } else if (error.message && error.message.includes('No winnings')) {
                    showMessage('No winnings to claim', 'error');
                } else {
                    showMessage('Claim failed: ' + (error?.reason || error?.message || 'Unknown error'), 'error');
                }
            }
        }

        // State for unclaimed winnings
        let unclaimedWinnings = []; // [{roundId, amount}]

        // Load all unclaimed winnings from blockchain
        async function loadUnclaimedWinnings() {
            console.log('[UNCLAIMED] loadUnclaimedWinnings called');
            console.log('[UNCLAIMED] gameContract:', !!gameContract, 'walletAddress:', walletAddress);

            if (!gameContract || !walletAddress) {
                document.getElementById('unclaimedPanel').style.display = 'none';
                console.log('[UNCLAIMED] No contract or wallet, hiding panel');
                return;
            }

            try {
                const round = await gameContract.getCurrentRound();
                const currentRound = Number(round.id);
                console.log('[UNCLAIMED] Current round:', currentRound);
                unclaimedWinnings = [];

                // Check last 20 rounds for unclaimed winnings
                for (let i = 1; i <= 20; i++) {
                    const roundId = currentRound - i;
                    if (roundId < 1) break;

                    try {
                        const result = await gameContract.checkResult(roundId, walletAddress);
                        const participated = result[0];
                        const won = result[3];
                        const claimed = result[4];
                        const winnings = Number(ethers.formatEther(result[5]));

                        if (participated && won && !claimed && winnings > 0) {
                            console.log('[UNCLAIMED] Found unclaimed round:', roundId, 'winnings:', winnings);
                            unclaimedWinnings.push({ roundId, amount: winnings });
                        }
                    } catch (e) {
                        // Round might not exist, skip
                    }
                }

                console.log('[UNCLAIMED] Total unclaimed:', unclaimedWinnings.length);
                updateUnclaimedUI();
            } catch (error) {
                console.error('Load unclaimed error:', error);
            }
        }

        // Update the unclaimed winnings UI
        function updateUnclaimedUI() {
            console.log('[UNCLAIMED] updateUnclaimedUI called, wallet:', walletAddress);
            const panel = document.getElementById('unclaimedPanel');
            const list = document.getElementById('unclaimedList');
            const total = document.getElementById('unclaimedTotal');
            const claimAllBtn = document.getElementById('claimAllBtn');

            if (!walletAddress) {
                panel.style.display = 'none';
                console.log('[UNCLAIMED] No wallet, hiding');
                return;
            }

            // Always show panel when wallet connected
            console.log('[UNCLAIMED] Showing panel!');
            panel.style.display = 'block';

            if (unclaimedWinnings.length === 0) {
                // Empty state
                total.textContent = '0 SCNDL';
                list.innerHTML = '<div class="no-unclaimed"> No unclaimed winnings. Play and win!</div>';
                claimAllBtn.style.display = 'none';
                return;
            }

            // Calculate total
            const totalAmount = unclaimedWinnings.reduce((sum, w) => sum + w.amount, 0);
            total.textContent = `${totalAmount.toFixed(0)} SCNDL`;

            // Build list HTML
            list.innerHTML = unclaimedWinnings.map(w => `
                <div class="unclaimed-item">
                    <span class="round-id">Round #${w.roundId}</span>
                    <span class="amount">+${w.amount.toFixed(1)} SCNDL</span>
                    <button class="claim-btn" onclick="claimSingleRound(${w.roundId})">CLAIM</button>
                </div>
            `).join('');

            // Show claim all button if multiple
            claimAllBtn.style.display = unclaimedWinnings.length > 1 ? 'block' : 'none';
        }

        // Claim a single round
        async function claimSingleRound(roundId) {
            await claimWinnings(roundId);
        }

        // Claim all unclaimed winnings
        async function claimAllWinnings() {
            if (unclaimedWinnings.length === 0) {
                showMessage('No winnings to claim', 'error');
                return;
            }

            showMessage(`Claiming ${unclaimedWinnings.length} rounds...`, 'info');

            for (const w of [...unclaimedWinnings]) {
                try {
                    await claimWinnings(w.roundId);
                } catch (e) {
                    console.error('Claim error for round', w.roundId, e);
                }
            }

            showMessage('All winnings claimed! ', 'success');
        }

        async function checkMyResult(roundId) {
            if (!walletAddress || !gameContract) return;

            // Prevent duplicate reporting
            if (reportedRounds.has(roundId)) {
                console.log('[DEBUG] Round already reported:', roundId);
                return;
            }

            try {
                console.log('[DEBUG] Checking result for round:', roundId);
                // Check result from blockchain contract
                const result = await gameContract.checkResult(roundId, walletAddress);
                // result = [participated, prediction, result, won, claimed, potentialWinnings]

                const participated = result[0];
                const won = result[3];
                const claimed = result[4];
                const winnings = Number(ethers.formatEther(result[5]));

                console.log('[DEBUG] Result:', { participated, won, claimed, winnings });

                if (!participated) {
                    console.log('[DEBUG] Did not participate in this round');
                    return;
                }

                // Update balance from blockchain
                await loadTokenBalance();

                if (won && !claimed) {
                    console.log('[DEBUG] WIN! Refreshing unclaimed panel...');
                    // Show WIN popup
                    showResult('win', winnings);
                    // Refresh unclaimed winnings panel
                    await loadUnclaimedWinnings();
                    // Notify server about win for stats (net profit = winnings - original bet)
                    const netProfit = Math.max(0, winnings - BET_AMOUNT);
                    fetch('/api/report-result', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ wallet: walletAddress, roundId, won: true, amount: netProfit })
                    }).catch(() => { });
                } else if (!won) {
                    // Show LOSE popup
                    showResult('lose', BET_AMOUNT);
                    // Notify server about loss for stats
                    fetch('/api/report-result', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ wallet: walletAddress, roundId, won: false, amount: BET_AMOUNT })
                    }).catch(() => { });
                }

                // Mark this round as reported to prevent duplicates
                reportedRounds.add(roundId);

                loadLastCycle();
            } catch (error) {
                console.error('Failed to check result:', error);
            }
        }

        function showMessage(text, type) {
            const msgEl = document.getElementById('voteMessage');
            msgEl.textContent = text;
            msgEl.className = `vote-message ${type}`;
            msgEl.style.display = 'block';
            setTimeout(() => { msgEl.style.display = 'none'; }, 4000);
        }


        async function loadLastCycle() {
            try {
                const res = await fetch('/api/last-cycle');
                const data = await res.json();

                // Sync check: if lastCycle.id != currentCycleId - 1, use currentCycleId - 1
                if (data.lastCycle) {
                    lastCycleData = data.lastCycle;
                    const displayId = data.currentCycleId ? data.currentCycleId - 1 : data.lastCycle.id;
                    document.getElementById('lastCycleNumber').textContent = displayId;
                    const resultEl = document.getElementById('lastCycleResult');
                    resultEl.textContent = data.lastCycle.action;
                    resultEl.className = 'last-cycle-result ' + data.lastCycle.action.toLowerCase();
                    document.getElementById('lastCycleArticles').textContent = data.lastCycle.articles.length + ' articles';
                    document.getElementById('lastCycleScore').textContent = 'Score: ' + data.lastCycle.averageScore;
                }
            } catch (error) { }
        }

        document.getElementById('rulesModal').addEventListener('click', (e) => {
            if (e.target.id === 'rulesModal') closeRules();
        });
        document.getElementById('lastCycleModal').addEventListener('click', (e) => {
            if (e.target.id === 'lastCycleModal') closeLastCycle();
        });

        // ============================================
        // ORACLE ARENA - Scales Animation + Refunds
        // ============================================

        // Update Oracle Arena scales based on pool data
        async function updateOracleArena() {
            try {
                const res = await fetch('/api/v2/pool-stats');
                const data = await res.json();

                // Update Hologram Slider percentages
                const holoMintPct = document.getElementById('holoMintPct');
                const holoNeutralPct = document.getElementById('holoNeutralPct');
                const holoBurnPct = document.getElementById('holoBurnPct');
                if (holoMintPct) holoMintPct.textContent = data.percentages.mint + '%';
                if (holoNeutralPct) holoNeutralPct.textContent = data.percentages.neutral + '%';
                if (holoBurnPct) holoBurnPct.textContent = data.percentages.burn + '%';

                // Update score display (use currentAverageScore)
                const holoScore = document.getElementById('holoScore');
                if (holoScore && typeof currentAverageScore !== 'undefined') {
                    holoScore.textContent = Math.round(currentAverageScore);
                }

                // Animate Hologram Slider indicator position using anime.js
                // Position ranges from 0% (full MINT) to 100% (full BURN)
                const holoIndicator = document.getElementById('holoIndicator');
                if (holoIndicator && typeof anime !== 'undefined') {
                    // Calculate position: 50% is neutral, <50% is mint-side, >50% is burn-side
                    let position = 50; // Default neutral
                    if (data.scaleTilt > 0) {
                        // Mint-heavy: move left (towards 0%)
                        position = Math.max(10, 50 - (data.scaleTilt / 2));
                    } else if (data.scaleTilt < 0) {
                        // Burn-heavy: move right (towards 100%)
                        position = Math.min(90, 50 - (data.scaleTilt / 2));
                    }

                    anime({
                        targets: holoIndicator,
                        left: position + '%',
                        duration: 800,
                        easing: 'easeOutElastic(1, 0.5)'
                    });
                }

                // Update pool total display
                const poolTotalEl = document.getElementById('poolTotal');
                if (poolTotalEl) {
                    poolTotalEl.textContent = data.totalPool.toLocaleString() + ' $SCNDL';
                }

                // Update pool bar widths
                const total = data.totalPool || 1;
                const mintPct = (data.pools.mint / total * 100) || 33;
                const neutralPct = (data.pools.neutral / total * 100) || 34;
                const burnPct = (data.pools.burn / total * 100) || 33;

                const mintBar = document.getElementById('poolBarMint');
                const neutralBar = document.getElementById('poolBarNeutral');
                const burnBar = document.getElementById('poolBarBurn');

                if (mintBar) mintBar.style.width = mintPct + '%';
                if (neutralBar) neutralBar.style.width = neutralPct + '%';
                if (burnBar) burnBar.style.width = burnPct + '%';

                // Update pool amounts
                const poolMint = document.getElementById('poolMint');
                const poolNeutral = document.getElementById('poolNeutral');
                const poolBurn = document.getElementById('poolBurn');
                if (poolMint) poolMint.textContent = Math.floor(data.pools.mint).toLocaleString();
                if (poolNeutral) poolNeutral.textContent = Math.floor(data.pools.neutral).toLocaleString();
                if (poolBurn) poolBurn.textContent = Math.floor(data.pools.burn).toLocaleString();

            } catch (e) {
                console.error('Error updating Oracle Arena:', e);
            }
        }

        // Check for pending refunds
        async function checkPendingRefunds() {
            if (!walletAddress) {
                document.getElementById('refundAlert').style.display = 'none';
                return;
            }

            try {
                const res = await fetch(`/api/v2/pending-refunds/${walletAddress}`);
                const data = await res.json();

                const refundAlert = document.getElementById('refundAlert');
                if (data.pendingRefunds && data.pendingRefunds.length > 0) {
                    refundAlert.style.display = 'flex';
                    document.getElementById('refundCount').textContent = data.pendingRefunds.length;
                } else {
                    refundAlert.style.display = 'none';
                }
            } catch (e) {
                console.error('Error checking refunds:', e);
            }
        }

        // Claim refunds (called from button)
        async function claimRefunds() {
            if (!walletAddress) {
                showMessage('Connect wallet first', 'error');
                return;
            }

            try {
                showMessage('Refunds are automatically added to your balance!', 'success');
                // Refunds are already credited to balance in server.js
                // Just refresh balance display
                await loadV2GameBalance();
                document.getElementById('refundAlert').style.display = 'none';
            } catch (e) {
                console.error('Claim refund error:', e);
                showMessage('Error claiming refund: ' + e.message, 'error');
            }
        }

        // Store current average score for arena display
        let currentAverageScore = 50;

        async function init() {
            // Load initial data without auto-connecting wallet
            // Note: Pool data comes from updateGameStatus() to avoid flickering
            await updateGameStatus();
            await updateOracleArena();
            await loadLeaderboard();
            await loadLastCycle();

            // Server sync every 3 seconds (for data updates including pool)
            setInterval(updateGameStatus, 3000);
            setInterval(updateOracleArena, 3000);
            setInterval(loadLeaderboard, 30000);
            setInterval(loadLastCycle, 30000);

            // Check pending refunds every 10 seconds (when wallet connected)
            setInterval(checkPendingRefunds, 10000);

            // Refresh wallet balance periodically (if wallet connected)
            setInterval(() => {
                if (walletAddress && tokenContract) {
                    loadTokenBalance();
                }
            }, 30000);

            // Local timer ticks every second (smooth countdown)
            setInterval(tickLocalTimer, 1000);
        }

        // Local timer tick - smooth countdown without network jitter
        function tickLocalTimer() {
            const timerEl = document.getElementById('votingTimer');
            // Calculate elapsed time since last server sync
            const elapsed = Math.floor((Date.now() - lastServerSync) / 1000);
            const displayValue = Math.max(0, localTimerValue - elapsed);
            timerEl.textContent = `${localTimerMode}: ${displayValue.toString().padStart(2, '0')}s`;
        }

        // Check for unclaimed winnings from previous rounds on page load
        async function checkUnclaimedWinnings() {
            await loadUnclaimedWinnings();
        }

        // Restore current bet state from server (after page refresh)
        async function restoreCurrentBet() {
            if (!walletAddress) return;

            try {
                // Use server API to get pending bet info
                const res = await fetch(`/api/v2/balance/${walletAddress}`);
                const data = await res.json();

                if (data.pendingBet && data.pendingBet.roundId && data.pendingBet.prediction) {
                    // User has pending bet in current round
                    myVote = data.pendingBet.prediction;
                    myBetAmount = data.pendingBet.amount || BET_AMOUNT;

                    // Highlight the button
                    document.querySelectorAll('.vote-btn').forEach(btn => btn.classList.remove('selected'));
                    const btnId = `vote${myVote.charAt(0).toUpperCase() + myVote.slice(1).toLowerCase()}`;
                    document.getElementById(btnId)?.classList.add('selected');

                    // Show bet info
                    document.getElementById('yourBet').style.display = 'block';
                    document.getElementById('yourBetAmount').textContent = myBetAmount;
                    document.getElementById('yourBetChoice').textContent = myVote;

                    console.log('Restored bet state from server:', myVote);
                }
            } catch (e) {
                console.error('Restore bet error:', e);
            }
        }

        // Clear session on page load (user requested NO persistence)
        function clearSessionOnLoad() {
            console.log('[SESSION] Clearing session on page load');
            localStorage.removeItem('scandals_wallet');
            localStorage.removeItem('scandals_lastActive');
            // Reset all wallet state
            walletAddress = null;
            web3Provider = null;
            web3Signer = null;
            tokenContract = null;
            gameContract = null;
            myVote = null;
            myBetAmount = 0;
        }

        // Call immediately on load - forces fresh connection each time
        clearSessionOnLoad();

        // Load last cycle data for panel display
        loadLastCycleData();

        // Start game status updates
        init();
    </script>
</body>

</html>